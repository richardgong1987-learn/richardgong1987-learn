(self.webpackChunkrichardgong_1987_learn=self.webpackChunkrichardgong_1987_learn||[]).push([[3031],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=a,f=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7093:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return m}});var r=n(22122),a=n(19756),o=(n(67294),n(3905)),i=["components"],l={},s=void 0,c={unversionedId:"c-computer/leetcode/BST/leetcode96",id:"c-computer/leetcode/BST/leetcode96",isDocsHomePage:!1,title:"leetcode96",description:"Given an integer n, return the number of structurally unique *BST'*s (binary search trees) which has exactly n nodes of unique values from 1 to n.",source:"@site/docs/c-computer/leetcode/BST/leetcode96.md",sourceDirName:"c-computer/leetcode/BST",slug:"/c-computer/leetcode/BST/leetcode96",permalink:"/richardgong1987-learn/docs/c-computer/leetcode/BST/leetcode96",editUrl:"https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/leetcode/BST/leetcode96.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"5.7 \u5982\u4f55\u8fd0\u7528\u8d2a\u5fc3\u601d\u60f3\u73a9\u8df3\u8dc3\u6e38\u620f",permalink:"/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/labuladong\u7b97\u6cd5\u5c0f\u6284\u4ee3\u7801/\u9ad8\u9891\u9762\u8bd5\u7cfb\u5217/\u8df3\u8dc3\u6e38\u620f"}},u=[{value:"First of all, let&#39;s make it clear that there are several cases of the root node",id:"first-of-all-lets-make-it-clear-that-there-are-several-cases-of-the-root-node",children:[]}],p={toc:u};function m(e){var t=e.components,l=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Given an integer ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),", return ",(0,o.kt)("em",{parentName:"p"},"the number of structurally unique ",(0,o.kt)("strong",{parentName:"em"},"BST'"),"s (binary search trees) which has exactly")," ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," ",(0,o.kt)("em",{parentName:"p"},"nodes of unique values from")," ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," ",(0,o.kt)("em",{parentName:"p"},"to")," ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg",src:n(13388).Z})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: n = 3\nOutput: 5\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: n = 1\nOutput: 1\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= n <= 19"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Before implementing this functionality, we have to have clear a clear understanding of the implementation of combination algorithm.")),(0,o.kt)("p",null,"Because we are based on the combination algorithm,"),(0,o.kt)("p",null,"I am not going to go into detail here,i provide an implementation here,read this code we have to understand the realization principle of  implement combination algorithm"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"/**\n *  e.g: javascript \n\n var output = [];\n getC([1,2,3], 2, 0, [], output);\n console.log(output);\n\n 0: (2) [1, 2]\n 1: (2) [1, 3]\n 2: (2) [2, 3]\n\n---------------------------\nrecurision step:\nstart = 0, init=[]\nstart = 1, init=[1]\nstart = 2, init=[1,2]\nstart = 3, init=[1,3]\nstart = 2, init=[2]\nstart = 3, init=[2,3]\nstart = 3, init=[3]\n\n */\nfunction getC(array, size, start, init, output) {\n    console.log(`start = ${start}, init=${JSON.stringify(init)}`)\n    if (init.length >= size) {\n        output.push(init);\n    } else {\n        for (let i = start; i < array.length; i++) {\n            getC(array, size, i + 1, init.concat(array[i]), output);\n        }\n    }\n}\n")),(0,o.kt)("p",null,"The detail of the recursive process:"),(0,o.kt)("h1",{id:"lets-analyze-this-problem"},"Let's analyze this problem"),(0,o.kt)("p",null,"For example, input"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"n=3\n")),(0,o.kt)("p",null,"The algorithm should return ",(0,o.kt)("strong",{parentName:"p"},"5")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Cos there are five different BST storage structures.the specific structure is as follows:")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg",src:n(13388).Z})),(0,o.kt)("p",null,"In fact, the essence of this problem is ",(0,o.kt)("strong",{parentName:"p"},"exhaustion")),(0,o.kt)("h2",{id:"first-of-all-lets-make-it-clear-that-there-are-several-cases-of-the-root-node"},"First of all, let's make it clear that there are several cases of the root node"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"there are obviously five root node in the example,  cos every number can be the root node"),(0,o.kt)("li",{parentName:"ul"},"If we choose ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"3")," as the root node, the left subtree is the combination of ",(0,o.kt)("inlineCode",{parentName:"strong"},"{1,2}")," and the right subtree is combination of  ",(0,o.kt)("inlineCode",{parentName:"strong"},"{4,5}"))),(0,o.kt)("li",{parentName:"ul"},"The multiplication of the number of combination of the left subtree and the number of combination of right subtree is the number of BSTs when 3 is the root node")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image-20211015011730043",src:n(79435).Z})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"we now understand his combination, but how to calculate it?")),(0,o.kt)("p",null,"In fact, all you need is ",(0,o.kt)("strong",{parentName:"p"},"recursion")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// definition: the number of the close interval [start,end],\n//which can be combined into count(int start, int end) BSTs\nint count(int start, int end){}\n")))}m.isMDXComponent=!0},79435:function(e,t,n){"use strict";t.Z=n.p+"assets/images/image-20211015011730043-05661ff0f2968cb32ce7e8f6e517c0a7.png"},13388:function(e,t,n){"use strict";t.Z=n.p+"assets/images/uniquebstn3-42e7e33436742fb224d0603a15467262.jpg"}}]);