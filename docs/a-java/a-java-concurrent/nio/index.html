<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">NIO【网络编程和】 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/a-java-concurrent/nio"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="NIO【网络编程和】 | 学习大使"><meta data-react-helmet="true" name="description" content="教学目标"><meta data-react-helmet="true" property="og:description" content="教学目标"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/a-java-concurrent/nio"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/a-java-concurrent/nio" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/a-java-concurrent/nio" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.dbbb0874.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.cc3f0661.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java架构师</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/intro">Java架构师学习内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">java并发编程</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/intro">Java并发编程</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">concurent</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/nio">NIO【网络编程和】</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/threadlocal">ThreadLocal全面解析</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">threadpool</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">java-jvm性能调优</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">java服务架构</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">计算机机科学</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>NIO【网络编程和】</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="教学目标"></a>教学目标<a class="hash-link" href="#教学目标" title="Direct link to heading">#</a></h2><ul class="contains-task-list"><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够辨别UDP和TCP协议特点</p><ul><li>UDP 无连接，基于数据包，发出去就不管了，性能好，可能丢失数据。</li><li>TCP有连接，基于通信管道，可靠传输。</li></ul></li><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够说出TCP协议下两个常用类名称</p><ul><li>客户端Socket</li><li>服务端ServerSocket</li></ul></li><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够编写TCP协议下字符串数据传输程序</p><ul><li>参见代码！</li></ul></li><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够理解TCP协议下文件上传案例</p><ul><li>参见代码！</li></ul></li><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够理解TCP协议下BS案例</p><ul><li>参见代码！</li></ul></li><li class="task-list-item"><p><input type="checkbox" disabled=""> 能够说出NIO的优点。</p><ul><li><p>BIO:同步阻塞式通信，线程要与客户端耦合，没有数据还要死等！并发越高，死的越快！！</p></li><li><p>NIO:同步非阻塞：只需要开始一个线程接收无数个客户端，再开启一个线程负责轮询所有的客户端</p><p>​	是否有数据，有数据才开启一个线程处理它。适合连接多但是数据短的连接。</p><p>​	性能较好！！</p></li></ul></li></ul><header><h1>第一章 网络编程入门</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="11软件结构"></a>1.1软件结构<a class="hash-link" href="#11软件结构" title="Direct link to heading">#</a></h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img alt="1566446300784" src="/richardgong1987-learn/assets/images/01_CS架构-c5a7d514cedb1f5f0083ad0925993da5.png"></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img alt="1566446315067" src="/richardgong1987-learn/assets/images/02_BS架构-e73582637dc38b8fdca5501e5e9ea8e9.png"></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="12-网络通信协议"></a>1.2 网络通信协议<a class="hash-link" href="#12-网络通信协议" title="Direct link to heading">#</a></h2><ul><li><p><strong>网络通信协议：</strong>通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 </p></li><li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p></li></ul><p><img alt="1566446331855" src="/richardgong1987-learn/assets/images/03_通讯协议-76cf4f01560cede57731b4e2a761c01a.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="13-协议分类"></a>1.3 协议分类<a class="hash-link" href="#13-协议分类" title="Direct link to heading">#</a></h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。<ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。服务器你死了吗？</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。我活着啊！！</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。我知道了！！</li></ul></li></ul></li></ul><p><img alt="1566446712862" src="/richardgong1987-learn/assets/images/04_TCP协议三次握手-7b519fdcdf9f2d1121f05f55c5b805a2.png"></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><ul><li><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP协议是一个<strong>面向无连接</strong>的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="14-网络编程三要素"></a>1.4 网络编程三要素<a class="hash-link" href="#14-网络编程三要素" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="协议"></a>协议<a class="hash-link" href="#协议" title="Direct link to heading">#</a></h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="ip地址"></a>IP地址<a class="hash-link" href="#ip地址" title="Direct link to heading">#</a></h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类 </strong>   [][][][] o o o o</p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ipconfig</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>检查网络是否连通，在控制台输入：</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ping 空格 IP地址</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ping 220.181.57.216</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ping www.baidu.com</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="端口号"></a>端口号<a class="hash-link" href="#端口号" title="Direct link to heading">#</a></h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。ddress</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    InetAddress类概述</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 一个该类的对象就代表一个IP地址对象。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    InetAddress类成员方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * static InetAddress getLocalHost()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            * 获得本地主机IP地址对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * static InetAddress getByName(String host)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            * 根据IP地址字符串或主机名获得对应的IP地址对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * String getHostName();获得主机名</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * String getHostAddress();获得IP地址字符串</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class InetAddressDemo01 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得本地主机IP地址对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        InetAddress inet01 = InetAddress.getLocalHost();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // pkxingdeMacBook-Pro.local/10.211.55.2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 主机名/ip地址字符串</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(inet01);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据IP地址字符串或主机名获得对应的IP地址对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // InetAddress inet02 = InetAddress.getByName(&quot;192.168.73.97&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        InetAddress inet02 = InetAddress.getByName(&quot;baidu.com&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(inet02);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得主机名</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String hostName = inet01.getHostName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(hostName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得IP地址字符串</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String hostAddress = inet01.getHostAddress();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(hostName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(hostAddress);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>第二章 UDP通信程序</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="21-udp协议概述"></a>2.1 UDP协议概述<a class="hash-link" href="#21-udp协议概述" title="Direct link to heading">#</a></h2><p>​       UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>​		由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>​		但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP通信过程如下图所示：</p><p><img alt="1566447182200" src="/richardgong1987-learn/assets/images/05_UDP通信过程-531409db79571bc9de8ed1a7d69fb429.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">UDP协议的特点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 面向无连接的协议</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 发送端只管发送，不确认对方是否能收到。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 基于数据包进行数据传输。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 发送数据的大小限制64K以内</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 因为面向无连接，速度快，但是不可靠。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">UDP协议的使用场景</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 即时通讯</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 在线视频</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 网络语音电话</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">UDP协议相关的两个类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DatagramPacket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 数据包对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 作用：用来封装要发送或要接收的数据，比如：集装箱</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DategramSocket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 发送对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 作用：用来发送或接收数据包，比如：码头</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">DatagramPacket类构造方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 创建发送端数据包对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * buf：要发送的内容，字节数组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * length：要发送内容的长度，单位是字节</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * address：接收端的IP地址对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * port：接收端的端口号</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DatagramPacket(byte[] buf, int length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 创建接收端的数据包对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * buf：用来存储接收到内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * length：能够接收内容的长度</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">DatagramPacket类常用方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * int getLength() 获得实际接收到的字节个数</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">DatagramSocket类构造方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DatagramSocket() 创建发送端的Socket对象，系统会随机分配一个端口号。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * DatagramSocket(int port) 创建接收端的Socket对象并指定端口号</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">DatagramSocket类成员方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * void send(DatagramPacket dp) 发送数据包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * void receive(DatagramPacket p) 接收数据包</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="22-udp通信案例"></a>2.2 UDP通信案例<a class="hash-link" href="#22-udp通信案例" title="Direct link to heading">#</a></h2><ul><li>需求：教师的电脑的一个程序发送数据，一个程序接收数据，使用的教师本机的ip。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="221-udp发送端代码实现"></a>2.2.1 UDP发送端代码实现<a class="hash-link" href="#221-udp发送端代码实现" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// UDP发送端代码实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UDPSender {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)throws Exception{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义一个字符串：要发送的内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String message = &quot;约吗&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 字符串转字节数组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] buf = message.getBytes();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建数据包对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramPacket dp = new DatagramPacket(buf,buf.length,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                InetAddress.getLocalHost(),6666);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建发送端的发送对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket ds = new DatagramSocket(8888);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发送数据包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.send(dp);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭发送对象释放端口号</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="222-udp接收端代码实现"></a>2.2.2 UDP接收端代码实现<a class="hash-link" href="#222-udp接收端代码实现" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    UDP协议接收端代码实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UDPReceive {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)throws Exception{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建接收对象DatagramSocket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket ds = new DatagramSocket(6666);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建字节数组用来存储接收接收到的内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] buf = new byte[1024];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建数据包对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramPacket dp = new DatagramPacket(buf,buf.length);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 接收数据包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.receive(dp);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得实际接收到的字节个数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = dp.getLength();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;len = &quot; + len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将字节数组的内容转换为字符串输出</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(new String(buf,0,len));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得发送端的ip地址</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String sendIp = dp.getAddress().getHostAddress();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得发送端的端口号</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port  = dp.getPort();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(sendIp);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(port);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>第三章 TCP通信程序</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="31-tcp协议概述"></a>3.1 TCP协议概述<a class="hash-link" href="#31-tcp协议概述" title="Direct link to heading">#</a></h2><ul><li>TCP协议是面向连接的通信协议，即在传输数据前先在客户端和服务器端建立逻辑连接，然后再传输数据。它提供了两台计算机之间可靠无差错的数据传输。TCP通信过程如下图所示：</li></ul><p><img alt="1566446503937" src="/richardgong1987-learn/assets/images/06_TCP通信过程-2bf5b71ebec37128fc76097f336c62e9.png"></p><p>第一次握手：
客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。</p><p>第二次握手：
服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p><p>第三次握手：
客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">TCP ==&gt; Transfer Control Protocol ==&gt; 传输控制协议</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TCP协议的特点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 面向连接的协议</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 只能由客户端主动发送数据给服务器端，服务器端接收到数据之后，可以给客户端响应数据。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 通过三次握手建立连接，连接成功形成数据传输通道。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 通过四次挥手断开连接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 基于IO流进行数据传输</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 传输数据大小没有限制</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 因为面向连接的协议，速度慢，但是是可靠的协议。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TCP协议的使用场景</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 文件上传和下载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 邮件发送和接收</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 远程登录</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TCP协议相关的类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Socket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 一个该类的对象就代表一个客户端程序。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * ServerSocket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 一个该类的对象就代表一个服务器端程序。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Socket类构造方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Socket(String host, int port)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 根据ip地址字符串和端口号创建客户端Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 注意事项：只要执行该方法，就会立即连接指定的服务器程序，如果连接不成功，则会抛出异常。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            如果连接成功，则表示三次握手通过。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Socket类常用方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * OutputStream getOutputStream(); 获得字节输出流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    * InputStream getInputStream();获得字节输入流对象</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="32-tcp通信案例"></a>3.2 TCP通信案例<a class="hash-link" href="#32-tcp通信案例" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="322-客户端向服务器发送数据"></a>3.2.2 客户端向服务器发送数据<a class="hash-link" href="#322-客户端向服务器发送数据" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TCP客户端代码实现步骤</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 创建客户端Socket对象并指定服务器地址和端口号</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用Socket对象的getOutputStream方法获得字节输出流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用字节输出流对象的write方法往服务器端输出数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用Socket对象的getInputStream方法获得字节输入流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用字节输入流对象的read方法读取服务器端返回的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 关闭Socket对象断开连接。</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// TCP客户端代码实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TCPClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 要发送的内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String content = &quot;你好TCP服务器端，约吗&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket socket = new Socket(&quot;192.168.73.99&quot;,9999);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // System.out.println(socket);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得字节输出流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        OutputStream out = socket.getOutputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 输出数据到服务器端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        out.write(content.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得字节输入流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStream in = socket.getInputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建字节数组：用来存储读取到服务器端数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] buf = new byte[1024];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取服务器端返回的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = in.read(buf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;len = &quot; + len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;服务器端返回的内容 = &quot; + new String(buf,0,len));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="333-服务器向客户端回写数据"></a>3.3.3 服务器向客户端回写数据<a class="hash-link" href="#333-服务器向客户端回写数据" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TCP服务器端代码实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ServerSocket类构造方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * ServerSocket(int port) 根据指定的端口号开启服务器。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ServerSocket类常用方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        *  Socket accept() 等待客户端连接并获得与客户端关联的Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TCP服务器端代码实现步骤</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 创建ServerSocket对象并指定端口号(相当于开启了一个服务器)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用ServerSocket对象的accept方法等待客端户连接并获得对应Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用Socket对象的getInputStream方法获得字节输入流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用字节输入流对象的read方法读取客户端发送的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用Socket对象的getOutputStream方法获得字节输出流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 调用字节输出流对象的write方法往客户端输出数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 关闭Socket和ServerSocket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TCPServer {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)throws Exception{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建服务器ocket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocket serverSocket = new ServerSocket(9999);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 等待客户端连接并获得与客户端关联的Socket对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket socket = serverSocket.accept();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得字节输入流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStream in = socket.getInputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建字节数组：用来存储读取到客户端发送的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] buf = new byte[1024];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取客户端发送过来的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = in.read(buf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;len = &quot; + len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;客户端发送的数据 = &quot; + new String(buf,0,len));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获得字节输出流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        OutputStream out = socket.getOutputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 往客户端输出数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        out.write(&quot;约你妹&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭socket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭服务器（在实际开发中，服务器一般不会关闭）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        serverSocket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>第四章 综合案例</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="41-文件上传案例"></a>4.1 文件上传案例<a class="hash-link" href="#41-文件上传案例" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="文件上传分析图解"></a>文件上传分析图解<a class="hash-link" href="#文件上传分析图解" title="Direct link to heading">#</a></h3><ol><li><p>【客户端】输入流，从硬盘读取文件数据到程序中。</p></li><li><p>【客户端】输出流，写出文件数据到服务端。</p></li><li><p>【服务端】输入流，读取文件数据到服务端程序。</p></li><li><p>【服务端】输出流，写出文件数据到服务器硬盘中。</p></li><li><p>【服务端】获取输出流，回写数据。</p></li><li><p>【客户端】获取输入流，解析回写数据。</p></li></ol><p><img alt="1566446548503" src="/richardgong1987-learn/assets/images/07_文件上传图解-4839e128626ba703f37bc2aa710299bb.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="案例实现"></a>案例实现<a class="hash-link" href="#案例实现" title="Direct link to heading">#</a></h3><p>服务器端实现：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class FileUpload_Server {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;服务器 启动.....  &quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1. 创建服务端ServerSocket</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocket serverSocket = new ServerSocket(6666);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. 循环接收,建立连接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Socket accept = serverSocket.accept();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            3. socket对象交给子线程处理,进行读写操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //3.1 获取输入流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //3.2 创建输出流对象, 保存到本地 .</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + &quot;.jpg&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BufferedOutputStream bos = new BufferedOutputStream(fis);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 3.3 读写数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    byte[] b = new byte[1024 * 8];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int len;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while ((len = bis.read(b)) != -1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        bos.write(b, 0, len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 4.=======信息回写===========================</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;back ........&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    OutputStream out = accept.getOutputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    out.write(&quot;上传成功&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    out.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //================================</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //5. 关闭 资源</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    bos.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    bis.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    accept.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;文件上传已保存&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (IOException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>客户端实现：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class FileUpload_Client {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.创建流对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.1 创建输入流,读取本地文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;test.jpg&quot;));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1.2 创建输出流,写到服务端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket socket = new Socket(&quot;localhost&quot;, 6666);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //2.写出数据.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] b  = new byte[1024 * 8 ];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len ;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (( len  = bis.read(b))!=-1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            bos.write(b, 0, len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭输出流,通知服务端,写出数据完毕</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.shutdownOutput();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;文件发送完毕&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3. =====解析回写============</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStream in = socket.getInputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] back = new byte[20];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        in.read(back);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(new String(back));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        in.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ============================</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.释放资源</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        bis.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="42-模拟bs服务器"></a>4.2 模拟B\S服务器<a class="hash-link" href="#42-模拟bs服务器" title="Direct link to heading">#</a></h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="案例分析"></a>案例分析<a class="hash-link" href="#案例分析" title="Direct link to heading">#</a></h3><ol><li>准备页面数据，web文件夹。</li><li>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问，查看网页效果</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="案例实现-1"></a>案例实现<a class="hash-link" href="#案例实现-1" title="Direct link to heading">#</a></h3><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ServerDemo {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocket server = new ServerSocket(8888);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Socket socket = server.accept();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new Web(socket)).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Web implements Runnable{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Socket socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Web(Socket socket){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.socket=socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //转换流,读取浏览器请求第一行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            BufferedReader readWb = new</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String requst = readWb.readLine();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //取出请求资源的路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String[] strArr = requst.split(&quot; &quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(Arrays.toString(strArr));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String path = strArr[1].substring(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(path);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            FileInputStream fis = new FileInputStream(path);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(fis);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte[] bytes= new byte[1024];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int len = 0 ;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //向浏览器 回写数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            OutputStream out = socket.getOutputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.write(&quot;HTTP/1.1 200 OK\r\n&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.write(&quot;Content-Type:text/html\r\n&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.write(&quot;\r\n&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while((len = fis.read(bytes))!=-1){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                out.write(bytes,0,len);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            fis.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            readWb.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(Exception ex){</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>访问效果：</strong></p><p><img alt="1566446578300" src="/richardgong1987-learn/assets/images/08_BS服务器案例效果图-bdc7802cada83c910cf703243e976ec6.png"></p><p><strong>图解：</strong></p><p><img alt="1566446643154" src="/richardgong1987-learn/assets/images/09_BS通讯图解-f3e97ac430efcb7d36491fc3c53874e5.png"></p><header><h1>第五章 NIO</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="51-nio概述"></a>5.1 NIO概述<a class="hash-link" href="#51-nio概述" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="511--nio引入"></a>5.1.1  NIO引入<a class="hash-link" href="#511--nio引入" title="Direct link to heading">#</a></h3><p>在我们学习Java的NIO流之前，我们都要了解几个关键词</p><ul><li>同步与异步（synchronous/asynchronous）：<strong>同步</strong>是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而<strong>异步</strong>则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</li><li>阻塞与非阻塞：在进行<strong>阻塞</strong>操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或者数据读取、写入操作完成；而<strong>非阻塞</strong>则是不管IO操作是否结束，直接返回，相应操作在后台继续处理</li></ul><p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，<strong>而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个操作在一步中产生或者消费一个数据库，按块处理要比按字节处理数据快的多。</strong></p><p>在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="52-nio同步、非阻塞"></a>5.2 NIO(同步、非阻塞)<a class="hash-link" href="#52-nio同步、非阻塞" title="Direct link to heading">#</a></h2><p><strong>NIO之所以是同步，是因为它的accept/read/write方法的内核I/O操作都会阻塞当前线程</strong></p><p>首先，我们要先了解一下NIO的三个主要组成部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="521-channel（通道）"></a><strong>5.2.1 Channel（通道）</strong><a class="hash-link" href="#521-channel（通道）" title="Direct link to heading">#</a></h3><p>Channel（通道）：Channel是一个对象，可以通过它读取和写入数据。可以把它看做是IO中的流，不同的是：</p><ul><li>Channel是双向的，既可以读又可以写，而流是单向的</li><li>Channel可以进行异步的读写</li><li>对Channel的读写必须通过buffer对象</li></ul><p>正如上面提到的，所有数据都通过Buffer对象处理，所以，您永远不会将字节直接写入到Channel中，相反，您是将数据写入到Buffer中；同样，您也不会从Channel中读取字节，而是将数据从Channel读入Buffer，再从Buffer获取这个字节。</p><p>因为Channel是双向的，所以Channel可以比流更好地反映出底层操作系统的真实情况。特别是在Unix模型中，底层操作系统通常都是双向的。</p><p>在Java NIO中的Channel主要有如下几种类型：</p><ul><li>FileChannel：从文件读取数据的</li><li>DatagramChannel：读写UDP网络协议数据</li><li>SocketChannel：读写TCP网络协议数据</li><li>ServerSocketChannel：可以监听TCP连接</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="522-buffer"></a>5.2.2 Buffer<a class="hash-link" href="#522-buffer" title="Direct link to heading">#</a></h3><p>Buffer是一个对象，它包含一些要写入或者读到Stream对象的。应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。</p><p>在NIO中，所有的数据都是用Buffer处理的，它是NIO读写数据的中转池。Buffer实质上是一个数组，通常是一个字节数据，但也可以是其他类型的数组。但一个缓冲区不仅仅是一个数组，重要的是它提供了对数据的结构化访问，而且还可以跟踪系统的读写进程。</p><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p><p>1.写入数据到 Buffer；</p><p>2.调用 flip() 方法；</p><p>3.从 Buffer 中读取数据；</p><p>4.调用 clear() 方法或者 compact() 方法。</p><p>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><p>Buffer主要有如下几种：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>我们将通过CopyFile这个实力让大家体会NIO的操作过程。CopyFile执行三个基本的操作：创建一个Buffer，然后从源文件读取数据到缓冲区，然后再将缓冲区写入目标文件。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static void copyFileUseNIO(String src,String dst) throws IOException{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//声明源文件和目标文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileInputStream fi=new FileInputStream(new File(src));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileOutputStream fo=new FileOutputStream(new File(dst));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获得传输通道channel</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileChannel inChannel=fi.getChannel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileChannel outChannel=fo.getChannel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获得容器buffer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteBuffer buffer=ByteBuffer.allocate(1024);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //判断是否读完文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int eof =inChannel.read(buffer);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(eof==-1){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //重设一下buffer的position=0，limit=position</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            buffer.flip();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //开始写</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            outChannel.write(buffer);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //写完要重置buffer，重设position=0,limit=capacity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            buffer.clear();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        inChannel.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        outChannel.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fi.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fo.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}   </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="523-selector"></a>5.2.3 Selector<a class="hash-link" href="#523-selector" title="Direct link to heading">#</a></h3><p>首先需要了解一件事情就是线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p><p>Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了。</p><p>有了Selector，我们就可以利用一个线程来处理所有的channels。线程之间的切换对操作系统来说代价是很高的，并且每个线程也会占用一定的系统资源。所以，对系统来说使用的线程越少越好。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="1如何创建一个selector"></a>1.如何创建一个Selector<a class="hash-link" href="#1如何创建一个selector" title="Direct link to heading">#</a></h4><p>Selector 就是您注册对各种 I/O 事件兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Selector selector = Selector.open();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="2注册channel到selector"></a>2.注册Channel到Selector<a class="hash-link" href="#2注册channel到selector" title="Direct link to heading">#</a></h4><p>为了能让Channel和Selector配合使用，我们需要把Channel注册到Selector上。通过调用 channel.register（）方法来实现注册：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">channel.configureBlocking(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">SelectionKey key =channel.register(selector,SelectionKey.OP_READ);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>注意，注册的Channel 必须设置成异步模式 才可以,否则异步IO就无法工作，这就意味着我们不能把一个FileChannel注册到Selector，因为FileChannel没有异步模式，但是网络编程中的SocketChannel是可以的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="3关于selectionkey"></a>3.关于SelectionKey<a class="hash-link" href="#3关于selectionkey" title="Direct link to heading">#</a></h4><p>请注意对register()的调用的返回值是一个SelectionKey。 SelectionKey 代表这个通道在此 Selector 上注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p><p>SelectionKey中包含如下属性：</p><ul><li>The interest set</li><li>The ready set</li><li>The Channel</li><li>The Selector</li><li>An attached object (optional)</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="1-interest-set"></a>(1) Interest set<a class="hash-link" href="#1-interest-set" title="Direct link to heading">#</a></h5><p>就像我们在前面讲到的把Channel注册到Selector来监听感兴趣的事件，interest set就是你要选择的感兴趣的事件的集合。你可以通过SelectionKey对象来读写interest set:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int interestSet = selectionKey.interestOps();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE; </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过上面例子可以看到，我们可以通过用AND 和SelectionKey 中的常量做运算，从SelectionKey中找到我们感兴趣的事件。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="2-ready-set"></a>(2) Ready Set<a class="hash-link" href="#2-ready-set" title="Direct link to heading">#</a></h5><p>ready set 是通道已经准备就绪的操作的集合。在一次选Selection之后，你应该会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int readySet = selectionKey.readyOps();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>可以用像检测interest集合那样的方法，来检测Channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">selectionKey.isAcceptable();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">selectionKey.isConnectable();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">selectionKey.isReadable();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">selectionKey.isWritable();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="3-channel-和-selector"></a>(3) Channel 和 Selector<a class="hash-link" href="#3-channel-和-selector" title="Direct link to heading">#</a></h5><p>我们可以通过SelectionKey获得Selector和注册的Channel：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Channel  channel  = selectionKey.channel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Selector selector = selectionKey.selector(); </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="4-attach一个对象"></a>(4) Attach一个对象<a class="hash-link" href="#4-attach一个对象" title="Direct link to heading">#</a></h5><p>可以将一个对象或者更多信息attach 到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">selectionKey.attach(theObject);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Object attachedObj = selectionKey.attachment();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="4关于selectedkeys"></a>4.关于SelectedKeys()<a class="hash-link" href="#4关于selectedkeys" title="Direct link to heading">#</a></h4><p><strong>生产系统中一般会额外进行就绪状态检查</strong></p><p>一旦调用了select()方法，它就会返回一个数值，表示一个或多个通道已经就绪，然后你就可以通过调用selector.selectedKeys()方法返回的SelectionKey集合来获得就绪的Channel。请看演示方法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当你通过Selector注册一个Channel时，channel.register()方法会返回一个SelectionKey对象，这个对象就代表了你注册的Channel。这些对象可以通过selectedKeys()方法获得。你可以通过迭代这些selected key来获得就绪的Channel，下面是演示代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">while(keyIterator.hasNext()) { </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    SelectionKey key = keyIterator.next();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(key.isAcceptable()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // a connection was accepted by a ServerSocketChannel.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (key.isConnectable()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // a connection was established with a remote server.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (key.isReadable()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // a channel is ready for reading</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (key.isWritable()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // a channel is ready for writing</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    keyIterator.remove();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个循环遍历selected key的集合中的每个key，并对每个key做测试来判断哪个Channel已经就绪。</p><p>请注意循环中最后的keyIterator.remove()方法。Selector对象并不会从自己的selected key集合中自动移除SelectionKey实例。我们需要在处理完一个Channel的时候自己去移除。当下一次Channel就绪的时候，Selector会再次把它添加到selected key集合中。</p><p>SelectionKey.channel()方法返回的Channel需要转换成你具体要处理的类型，比如是ServerSocketChannel或者SocketChannel等等。</p><blockquote><p>IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="53-nio2（aio）异步、非阻塞"></a>5.3 NIO2（==AIO）(异步、非阻塞)<a class="hash-link" href="#53-nio2（aio）异步、非阻塞" title="Direct link to heading">#</a></h2><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p><p>但是对AIO来说，则更加进了一步，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p><ul><li>AsynchronousSocketChannel</li><li>AsynchronousServerSocketChannel</li><li>AsynchronousFileChannel</li><li>AsynchronousDatagramChannel</li></ul><p>在AIO socket编程中，服务端通道是AsynchronousServerSocketChannel，这个类提供了一个open()静态工厂，一个bind()方法用于绑定服务端IP地址（还有端口号），另外还提供了accept()用于接收用户连接请求。在客户端使用的通道是AsynchronousSocketChannel,这个通道处理提供open静态工厂方法外，还提供了read和write方法。</p><p>在AIO编程中，发出一个事件（accept read write等）之后要指定事件处理类（回调函数），AIO中的事件处理类是CompletionHandler&lt;V,A&gt;，这个接口定义了如下两个方法，分别在异步操作成功和失败时被回调。</p><p>void completed(V result, A attachment);</p><p>void failed(Throwable exc, A attachment);</p><p><strong>Netty框架</strong>：基于NIO 2.0封装好的通信框架，性能优异，稳定好，代码简单，大型技术大量公司经过实战使用以后，发现各方面都很好！！</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/a-java/a-java-concurrent/nio.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/concurent/readme"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 原理篇</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/threadlocal"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ThreadLocal全面解析 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#教学目标" class="table-of-contents__link">教学目标</a></li><li><a href="#11软件结构" class="table-of-contents__link">1.1软件结构</a></li><li><a href="#12-网络通信协议" class="table-of-contents__link">1.2 网络通信协议</a></li><li><a href="#13-协议分类" class="table-of-contents__link">1.3 协议分类</a></li><li><a href="#14-网络编程三要素" class="table-of-contents__link">1.4 网络编程三要素</a><ul><li><a href="#协议" class="table-of-contents__link">协议</a></li><li><a href="#ip地址" class="table-of-contents__link">IP地址</a></li><li><a href="#端口号" class="table-of-contents__link">端口号</a></li></ul></li><li><a href="#21-udp协议概述" class="table-of-contents__link">2.1 UDP协议概述</a></li><li><a href="#22-udp通信案例" class="table-of-contents__link">2.2 UDP通信案例</a><ul><li><a href="#221-udp发送端代码实现" class="table-of-contents__link">2.2.1 UDP发送端代码实现</a></li><li><a href="#222-udp接收端代码实现" class="table-of-contents__link">2.2.2 UDP接收端代码实现</a></li></ul></li><li><a href="#31-tcp协议概述" class="table-of-contents__link">3.1 TCP协议概述</a></li><li><a href="#32-tcp通信案例" class="table-of-contents__link">3.2 TCP通信案例</a><ul><li><a href="#322-客户端向服务器发送数据" class="table-of-contents__link">3.2.2 客户端向服务器发送数据</a></li><li><a href="#333-服务器向客户端回写数据" class="table-of-contents__link">3.3.3 服务器向客户端回写数据</a></li></ul></li><li><a href="#41-文件上传案例" class="table-of-contents__link">4.1 文件上传案例</a><ul><li><a href="#文件上传分析图解" class="table-of-contents__link">文件上传分析图解</a></li><li><a href="#案例实现" class="table-of-contents__link">案例实现</a></li></ul></li><li><a href="#42-模拟bs服务器" class="table-of-contents__link">4.2 模拟BS服务器</a><ul><li><a href="#案例分析" class="table-of-contents__link">案例分析</a></li><li><a href="#案例实现-1" class="table-of-contents__link">案例实现</a></li></ul></li><li><a href="#51-nio概述" class="table-of-contents__link">5.1 NIO概述</a><ul><li><a href="#511--nio引入" class="table-of-contents__link">5.1.1  NIO引入</a></li></ul></li><li><a href="#52-nio同步、非阻塞" class="table-of-contents__link">5.2 NIO(同步、非阻塞)</a><ul><li><a href="#521-channel（通道）" class="table-of-contents__link"><strong>5.2.1 Channel（通道）</strong></a></li><li><a href="#522-buffer" class="table-of-contents__link">5.2.2 Buffer</a></li><li><a href="#523-selector" class="table-of-contents__link">5.2.3 Selector</a></li></ul></li><li><a href="#53-nio2（aio）异步、非阻塞" class="table-of-contents__link">5.3 NIO2（==AIO）(异步、非阻塞)</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.dbbb0874.js"></script>
<script src="/richardgong1987-learn/assets/js/main.cc3f0661.js"></script>
</body>
</html>