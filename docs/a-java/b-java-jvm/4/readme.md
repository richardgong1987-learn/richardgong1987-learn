---
sidebar_position: 444
---
# 内存模型

## [4_内存模型.pdf](4_内存模型.pdf)

注意,内存结构和内存模型不是一回事

内存模型是用来定义一套在多线程读写共享数据时(成员变量,数组)时,

对数据的可见性,有序性,和原子性的规则和保障

## 1.原子性

解决办法

## 2.可见性

出不退的while循环

可以通过volatile来解决放到高速缓存

用volatile修饰过的变量,表示在读取的变量都

会到内存读取,避免因为高速缓存造成的

无法退出的while

但注意:

Volatile 不能保存原子性

volatile适合场景主要是在一个人写,多个人读,是比较适合的

System.out.println可以破坏调整缓存机制的原因是因为

println是加了synchoninzed关键字.

Synchominzed关键是是会破坏高速缓存的

## 3.有序性

volatile可以禁止指令重排

有极少的情况会因为运行时优化,会进行指令重排 的问题

而用volatile可以禁止指令重排

### 3.3 有序性理解

多线程下指令重排,会出现问题

双重判断单例模式实现

也会有双重指令重排.

这种情况下,可以用volatile解决

### Happens-before规则

#### java 有序性 happens-before八个原则

1 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。

一段程序的执行，在单个线程中看起来是有序的。程序次序规则看起来是按顺序执行的，因为虚拟机可能会对程序指令进行重排序。虽然进行了重排序但是最终执行的结果是与程序顺序执行的结果是一致的。它只会对不存在数据依赖行的指令进行重排序。该规则是用来保证程序在单线程执行结果的正确性。但是无法保证程序在多线程执行结果的正确性。



2 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。即无论在单线程还是多线程中，同一个锁如果处于被锁定状态，那么必须先对锁进行释放操作，后面才能继续执行lock操作。



3 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。



4 传递规则：如果操作A先行发生于操作B，而操作B先行发生于操作C，则可以得出操作A先行发生于操作C



5 线程启动原则：Thread对象的start()方法先行发生于此线程的每一个动作



6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。



7 线程终结规则：线程中所以的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thhread.isAlive()的返回值手段检测到线程已经终止执行。



8 对象终结规则：一个对象的初始化完成先行于它的finalize(()方法的开始。

## 4.CAS与原子类

### 4.1CAS 乐观锁

CAS, Compare and Swap乐观锁的思想

它不会线程堵塞

所以性能高

### 4.2 乐观锁与悲观锁

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。
- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。

#### 悲观锁

Synchronized 就是悲观锁的典型代表

### 4.3 原子操作类

Java.util.concurrent类

juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的

## 5.synchronized优化

synchronized锁对象的升级（膨胀）过程主要如下

**膨胀过程：**

无锁（锁对象初始化时）->

 偏向锁（有线程请求锁） -> 

轻量级锁（多线程轻度竞争）->

 重量级锁（线程过多或长耗时操作，线程自旋过度消耗cpu）



### 5.1 轻量级锁

如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻 量级锁来优化

### 5.2 锁膨胀

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻 量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。



### 5.3 重量锁

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退 出了同步块，释放了锁），这时当前线程就可以避免阻塞。

### 5.4 偏向锁

Java 6 中引入了偏向锁 

只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.



### 5.5 其它优化

#### 1.减少上锁时间

同步代码块中尽量短 

#### 2.减少锁的粒度

将一个锁拆分为多个锁提高并发度，

例如：ConcurrentHashMap

####  3. 锁粗化

多次循环进入同步块不如同步块内多次循环另外 JVM 可能会做如下优化，把多次 append 的加锁操作 粗化为一次（因为都是对同一个对象加锁，没必要重入多次）

```java
newStringBuffer().append("a").append("b").append("c");
```

#### 4.锁消除

JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候 就会被即时编译器忽略掉所有同步操作。



#### 5.读写分离

CopyOnWriteArrayListConyOnWriteSet



5.1 初始状态是轻量锁

- 轻量级锁

  synchronized初始是轻量锁

  轻量锁升级为重量锁就是叫:锁锁膨胀

  第二次加锁,可以叫锁重入

- 重量锁

  自动自旋重度状态:锁自旋

  如果自旋失败的话,就会陷入阻塞

- 偏向锁

  没有发生竞争,发生了锁重入

  偏向锁是在mark work写入的是自己的线程id

  这种其实就是没有锁.

  重偏向,表示多个没有竞争的偏向锁.

  从t1重新偏向了t2

- 其它优化

  - 减少上锁时间

  - 锁粗化

    多次循环进入同步代码块,不如同步代码块多次循环

  - 锁消除

  - 读写分离

  - 减少锁的粒度

    将一个锁拆分成多个锁,提高并发度,例如:

    - ConcurrentHashMap
    - LongAddrer
    - LinkedBlockingQueue 入队出队使用不同的锁
