---
sidebar_position: 444
---
# 内存模型

## [4_内存模型.pdf](4_内存模型.pdf)

注意,内存结构和内存模型不是一回事

内存模型是用来定义一套在多线程读写共享数据时(成员变量,数组)时,

对数据的可见性,有序性,和原子性的规则和保障

## 原子性

解决办法

## 可见性

出不退的while循环

可以通过volatile来解决放到高速缓存

用volatile修饰过的变量,表示在读取的变量都

会到内存读取,避免因为高速缓存造成的

无法退出的while

但注意:

Volatile 不能保存原子性

volatile适合场景主要是在一个人写,多个人读,是比较适合的

System.out.println可以破坏调整缓存机制的原因是因为

println是加了synchoninzed关键字.

Synchominzed关键是是会破坏高速缓存的

## 有序性

volatile可以禁止指令重排

有极少的情况会因为运行时优化,会进行指令重排 的问题

而用volatile可以禁止指令重排

### 3.3 有序性理解

多线程下指令重排,会出现问题

双重判断单例模式实现

也会有双重指令重排.

这种情况下,可以用volatile解决

### Happens-before规则

#### java 有序性 happens-before八个原则

1 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。

一段程序的执行，在单个线程中看起来是有序的。程序次序规则看起来是按顺序执行的，因为虚拟机可能会对程序指令进行重排序。虽然进行了重排序但是最终执行的结果是与程序顺序执行的结果是一致的。它只会对不存在数据依赖行的指令进行重排序。该规则是用来保证程序在单线程执行结果的正确性。但是无法保证程序在多线程执行结果的正确性。



2 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。即无论在单线程还是多线程中，同一个锁如果处于被锁定状态，那么必须先对锁进行释放操作，后面才能继续执行lock操作。



3 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。



4 传递规则：如果操作A先行发生于操作B，而操作B先行发生于操作C，则可以得出操作A先行发生于操作C



5 线程启动原则：Thread对象的start()方法先行发生于此线程的每一个动作



6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。



7 线程终结规则：线程中所以的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thhread.isAlive()的返回值手段检测到线程已经终止执行。



8 对象终结规则：一个对象的初始化完成先行于它的finalize(()方法的开始。


## CAS与原子类

### 乐观锁

CAS, Compare and Swap乐观锁的思想

它不会线程堵塞

所以性能高

### 悲观锁

Synchronized 就是悲观锁的典型代表

### 原子操作类

Java.util.concurrent类

## synchronized优化

初始状态是轻量锁

- 轻量级锁

  synchronized初始是轻量锁

  轻量锁升级为重量锁就是叫:锁锁膨胀

  第二次加锁,可以叫锁重入

- 重量锁

  自动自旋重度状态:锁自旋

  如果自旋失败的话,就会陷入阻塞

- 偏向锁

  没有发生竞争,发生了锁重入

  偏向锁是在mark work写入的是自己的线程id

  这种其实就是没有锁.

  重偏向,表示多个没有竞争的偏向锁.

  从t1重新偏向了t2

- 其它优化

  - 减少上锁时间

  - 锁粗化

    多次循环进入同步代码块,不如同步代码块多次循环

  - 锁消除

  - 读写分离

  - 减少锁的粒度

    将一个锁拆分成多个锁,提高并发度,例如:

    - ConcurrentHashMap
    - LongAddrer
    - LinkedBlockingQueue 入队出队使用不同的锁
