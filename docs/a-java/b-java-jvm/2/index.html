<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-a-java/b-java-jvm/2/readme">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">垃圾收回 | 学习大使</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="垃圾收回 | 学习大使"><meta data-rh="true" name="description" content="2垃圾回收.pdf"><meta data-rh="true" property="og:description" content="2垃圾回收.pdf"><link data-rh="true" rel="icon" href="/richardgong1987-learn/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/"><link data-rh="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/" hreflang="en"><link data-rh="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.5f5eafd0.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.dcd6332f.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.d8e191fe.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><div class="navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="" class="themedImage_ToTc themedImage--light_HNdA"><img src="/richardgong1987-learn/img/logo.svg" alt="" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">学习大使</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/intro">Java架构师学习内容目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/richardgong1987-learn/docs/a-java/a-java-concurrent/intro">java并发编程</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/intro">java-jvm性能调优</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/intro">JVM性能调优学习</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/1/">1.内存结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/2/">2.垃圾回收</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/3/">3.类加载和字节码技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/4/">4.内存模型</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/richardgong1987-learn/docs/a-java/c-java-architect/intro">java服务架构</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/kafka/">readme</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/rocketmq/">RocketMQ 问题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/richardgong1987-learn/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java架构师</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">java-jvm性能调优</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">2.垃圾回收</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>垃圾收回</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2_垃圾回收pdf"><a target="_blank" href="/richardgong1987-learn/assets/files/2_垃圾回收-548b59ea2ffb723023dba9505c9dae1e.pdf">2_垃圾回收.pdf</a><a class="hash-link" href="#2_垃圾回收pdf" title="Direct link to heading">​</a></h2><ol><li><p>如何判断对象可以回收</p></li><li><p>垃圾回收算法</p></li><li><p>分代垃圾回收</p></li><li><p>垃圾回收器</p></li><li><p>垃圾回收调优</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1如何判断对象可以回收">1.如何判断对象可以回收<a class="hash-link" href="#1如何判断对象可以回收" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="11-引用计数法">1.1 引用计数法<a class="hash-link" href="#11-引用计数法" title="Direct link to heading">​</a></h3><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712132244841.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712132244841" src="/richardgong1987-learn/assets/images/image-20200712132244841-d3abc1701865ee988db2bb2c014b235d.png" width="1260" height="484" class="img_ev3q"></a></p><p>代表作:早期的python vm听说是用这种算法的</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="12-可达性分析算法">1.2 可达性分析算法<a class="hash-link" href="#12-可达性分析算法" title="Direct link to heading">​</a></h3><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以</p><p>回收</p><p>哪些对象可以作为 GC Root ?</p><ul><li>System class系列的</li></ul><blockquote><p>如:java.lang.Class下的所有类</p></blockquote><ul><li>Native Stack</li><li>Thread</li><li>Busy Monitor</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="13-四种引用">1.3 四种引用<a class="hash-link" href="#13-四种引用" title="Direct link to heading">​</a></h3><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712134233199.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712134233199" src="/richardgong1987-learn/assets/images/image-20200712134233199-294fe6cf30d9d1cf4b87b72b809db0a7.png" width="2062" height="1098" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1强引用">1.强引用<a class="hash-link" href="#1强引用" title="Direct link to heading">​</a></h4><p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2软引用softreference">2.软引用（SoftReference）<a class="hash-link" href="#2软引用softreference" title="Direct link to heading">​</a></h4><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用</p><p>对象</p><p>可以配合引用队列来释放软引用自身</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3弱引用weakreference">3.弱引用（WeakReference）<a class="hash-link" href="#3弱引用weakreference" title="Direct link to heading">​</a></h4><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><p>可以配合引用队列来释放弱引用自身</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4虚引用phantomreference">4.虚引用（PhantomReference）<a class="hash-link" href="#4虚引用phantomreference" title="Direct link to heading">​</a></h4><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，</p><p>由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5终结器引用finalreference">5.终结器引用（FinalReference）<a class="hash-link" href="#5终结器引用finalreference" title="Direct link to heading">​</a></h4><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象</p><p>暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize</p><p>方法，第二次 GC 时才能回收被引用对象</p><p>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2垃圾回收算法">2.垃圾回收算法<a class="hash-link" href="#2垃圾回收算法" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-标记清除">2.1 标记清除<a class="hash-link" href="#21-标记清除" title="Direct link to heading">​</a></h3><p>定义： Mark Sweep</p><ul><li>速度较快</li><li>会造成内存</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712165945473.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712165945473" src="/richardgong1987-learn/assets/images/image-20200712165945473-8d969d161fe35ad54094d64a9104496a.png" width="1472" height="1020" class="img_ev3q"></a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-标记整理">2.2 标记整理<a class="hash-link" href="#22-标记整理" title="Direct link to heading">​</a></h3><p>定义：Mark Compact</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170023855.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712170023855" src="/richardgong1987-learn/assets/images/image-20200712170023855-09092e6617b26f8f7853c46c94541671.png" width="1530" height="854" class="img_ev3q"></a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="23-复制">2.3 复制<a class="hash-link" href="#23-复制" title="Direct link to heading">​</a></h3><p>定义：Copy</p><ul><li>不会有内存碎片</li><li>需要占用双倍内存空间</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170053771.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712170053771" src="/richardgong1987-learn/assets/images/image-20200712170053771-edcca8b37e55a39c81fdcb8d6c7a65ad.png" width="1596" height="552" class="img_ev3q"></a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3分代垃圾回收">3.分代垃圾回收<a class="hash-link" href="#3分代垃圾回收" title="Direct link to heading">​</a></h2><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170422301.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712170422301" src="/richardgong1987-learn/assets/images/image-20200712170422301-d67c525f0832bb4b3677beaa25a9d191.png" width="1706" height="500" class="img_ev3q"></a></p><ul><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的</p><p>对象年龄加 1并且交换 from to</p></li><li><p>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li><li><p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p></li><li><p>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时</p><p>间更长</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-相关-vm-参数">3.1 相关 VM 参数<a class="hash-link" href="#31-相关-vm-参数" title="Direct link to heading">​</a></h3><p>含义参数</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712172615432.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712172615432" src="/richardgong1987-learn/assets/images/image-20200712172615432-4a6c4242e62ade9880a2b889acecd62f.png" width="1708" height="870" class="img_ev3q"></a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4垃圾回收器">4.垃圾回收器<a class="hash-link" href="#4垃圾回收器" title="Direct link to heading">​</a></h2><ol><li><strong>串行</strong></li></ol><p>单线程</p><p>堆内存较小，适合个人电脑</p><ol><li><strong>吞吐量优先</strong></li></ol><p>多线程</p><p>堆内存较大，多核 cpu</p><p>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高</p><ol><li><strong>响应时间优先</strong></li></ol><p>多线程</p><p>堆内存较大，多核 cpu</p><p>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-串行">4.1 串行<a class="hash-link" href="#41-串行" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+UseSerialGC = Serial + SerialOld     其中:Serial使用复制算法.  SerialOld使用标记加整理算法</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182645657.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712182645657" src="/richardgong1987-learn/assets/images/image-20200712182645657-c626951a3582804b60f9a3847c3bed23.png" width="1626" height="472" class="img_ev3q"></a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-吞吐量优先">4.2 吞吐量优先<a class="hash-link" href="#42-吞吐量优先" title="Direct link to heading">​</a></h3><p>jdk1.8默认使用.</p><p><strong>缺点:</strong> 多核cpu才能发挥其性能</p><p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p><p>复制算法 标记加整理算法</p><p>-XX:+UseAdaptiveSizePolicy</p><p>-XX:GCTimeRatio=ratio</p><p>-XX:MaxGCPauseMillis=ms</p><p>-XX:ParallelGCThreads=n</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182842864.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712182842864" src="/richardgong1987-learn/assets/images/image-20200712182842864-64e0c00dfcc2c814fe868e01d93a8b08.png" width="1610" height="470" class="img_ev3q"></a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="43-响应时间优先">4.3 响应时间优先<a class="hash-link" href="#43-响应时间优先" title="Direct link to heading">​</a></h3><p>CMS收回器</p><p><strong>缺点:</strong>容易碎片多. 并发会失败</p><p>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</p><p>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</p><p>-XX:CMSInitiatingOccupancyFraction=percent</p><p>-XX:+CMSScavengeBeforeRemark</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182917164.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712182917164" src="/richardgong1987-learn/assets/images/image-20200712182917164-d90e8c6cf529c701fc379fc575826adf.png" width="1640" height="440" class="img_ev3q"></a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="44-g1">4.4 G1<a class="hash-link" href="#44-g1" title="Direct link to heading">​</a></h3><p>吞吐量和响应的折中回收器</p><p><strong>定义：Garbage First</strong></p><ul><li>2004 论文发布</li><li>2009 JDK 6u14 体验</li><li>2012 JDK 7u4 官方支持</li><li>2017 JDK 9 默认</li></ul><p><strong>适用场景</strong></p><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p><p>超大堆内存，会将堆划分为多个大小相等的 Region</p><p>整体上是标记+整理算法，两个区域之间是复制算法</p><p><strong>相关 JVM 参数</strong></p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize=size</p><p>-XX:MaxGCPauseMillis=time</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-g1-垃圾回收阶段">1) G1 垃圾回收阶段<a class="hash-link" href="#1-g1-垃圾回收阶段" title="Direct link to heading">​</a></h4><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712184846275.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712184846275" src="/richardgong1987-learn/assets/images/image-20200712184846275-98e93b28c35eb5dea48d6933920d7cfd.png" width="1588" height="1314" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-young-collection">2) Young Collection<a class="hash-link" href="#2-young-collection" title="Direct link to heading">​</a></h4><ul><li><p>会 STW</p></li><li><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185019409.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712185019409" src="/richardgong1987-learn/assets/images/image-20200712185019409-af0dde0978ea1d1b31da319227655b18.png" width="1618" height="1092" class="img_ev3q"></a></p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185005082.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712185005082" src="/richardgong1987-learn/assets/images/image-20200712185005082-eb5bfc55ea565fc99d1bb717468476a4.png" width="1576" height="1186" class="img_ev3q"></a></p></li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185104291.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712185104291" src="/richardgong1987-learn/assets/images/image-20200712185104291-7bab7e9ded1c197807c798bbf2900259.png" width="1646" height="1220" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-young-collection--cm">3) Young Collection + CM<a class="hash-link" href="#3-young-collection--cm" title="Direct link to heading">​</a></h4><p>在 Young GC 时会进行 GC Root 的初始标记</p><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</p><p>-XX:InitiatingHeapOccupancyPercent</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202654480.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712202654480" src="/richardgong1987-learn/assets/images/image-20200712202654480-e4fd99f6d1d156bc78c8cda2f9761a1a.png" width="1620" height="1186" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-mixed-collection">4) Mixed Collection<a class="hash-link" href="#4-mixed-collection" title="Direct link to heading">​</a></h4><p>会对 E、S、O 进行全面垃圾回收</p><p>最终标记（Remark）会 STW</p><p>拷贝存活（Evacuation）会 STW</p><p>-XX:MaxGCPauseMillis=ms</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202711209.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712202711209" src="/richardgong1987-learn/assets/images/image-20200712202711209-54d2ef6154a515d952dea3909446d709.png" width="1668" height="1216" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-full-gc">5) Full GC<a class="hash-link" href="#5-full-gc" title="Direct link to heading">​</a></h4><p><strong>SerialGC</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p><strong>ParallelGC</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p><strong>CMS</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><p><strong>G1</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6-young-collection-跨代引用">6) Young Collection 跨代引用<a class="hash-link" href="#6-young-collection-跨代引用" title="Direct link to heading">​</a></h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202837130.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712202837130" src="/richardgong1987-learn/assets/images/image-20200712202837130-5c0e5be07c5765a28f6770d90d0049c8.png" width="1754" height="846" class="img_ev3q"></a></p><ul><li>卡表与 Remembered Set</li><li>在引用变更时通过 post-write barrier + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202926543.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712202926543" src="/richardgong1987-learn/assets/images/image-20200712202926543-4f3f91781ec273f5b78dd26dc231d66f.png" width="1752" height="932" class="img_ev3q"></a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="7-remark">7) Remark<a class="hash-link" href="#7-remark" title="Direct link to heading">​</a></h4><ul><li><p>pre-write barrier + satb_mark_queue</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712203006661.png" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="image-20200712203006661" src="/richardgong1987-learn/assets/images/image-20200712203006661-921f6bf3741a33d6aa2329b98562e148.png" width="1622" height="786" class="img_ev3q"></a></p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8-jdk-8u20-字符串去重">8) JDK 8u20 字符串去重<a class="hash-link" href="#8-jdk-8u20-字符串去重" title="Direct link to heading">​</a></h4><ul><li><p>优点：节省大量内存</p></li><li><p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+UseStringDeduplication</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String s1 = new String(&quot;hello&quot;); // char[]{&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s2 = new String(&quot;hello&quot;); // char[]{&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>将所有新分配的字符串放入一个队列</p></li><li><p>当新生代回收时，G1并发检查是否有字符串重复</p></li><li><p>如果它们值一样，让它们引用同一个 char[]</p><ul><li>注意，与 String.intern() 不一样</li><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="9-jdk-8u40-并发标记类卸载">9) JDK 8u40 并发标记类卸载<a class="hash-link" href="#9-jdk-8u40-并发标记类卸载" title="Direct link to heading">​</a></h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸</p><p>载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10-jdk-8u60-回收巨型对象">10) JDK 8u60 回收巨型对象<a class="hash-link" href="#10-jdk-8u60-回收巨型对象" title="Direct link to heading">​</a></h4><p>一个对象大于 region 的一半时，称之为巨型对象</p><p>G1 不会对巨型对象进行拷贝</p><p>回收时被优先考虑</p><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生</p><p>代垃圾回收时处理掉</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="11-jdk-9-并发标记起始时间的调整">11) JDK 9 并发标记起始时间的调整<a class="hash-link" href="#11-jdk-9-并发标记起始时间的调整" title="Direct link to heading">​</a></h4><ul><li><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p></li><li><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</p></li><li><p>JDK 9 可以动态调整</p><ul><li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul><h4></h4></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="12-jdk-9-更高效的回收">12) JDK 9 更高效的回收<a class="hash-link" href="#12-jdk-9-更高效的回收" title="Direct link to heading">​</a></h4><p>预备知识</p><p>掌握 GC 相关的 VM 参数，会基本的空间调整</p><p>掌握相关工具</p><p>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5垃圾回收调优">5.垃圾回收调优<a class="hash-link" href="#5垃圾回收调优" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-调优领域">5.1 调优领域<a class="hash-link" href="#51-调优领域" title="Direct link to heading">​</a></h3><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-确定目标">5.2 确定目标<a class="hash-link" href="#52-确定目标" title="Direct link to heading">​</a></h3><ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-最快的-gc">5.3 最快的 GC<a class="hash-link" href="#53-最快的-gc" title="Direct link to heading">​</a></h3><p>答案是:不发生 GC,才是最快的GC</p><ul><li>查看 FullGC 前后的内存占用，考虑下面几个问题<ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(&quot;select * from 大表 limit n&quot;)</li></ul></li><li>数据表示是否太臃肿？<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏？<ul><li>static Map map =</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-新生代调优">5.4 新生代调优<a class="hash-link" href="#54-新生代调优" title="Direct link to heading">​</a></h3><ul><li>新生代的特点<ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价是零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远远低于 Full GC</li></ul></li><li>越大越好吗？</li></ul><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).</p><p>GC is performed in this region more often than in other regions. If the size for the young</p><p>generation is too small, then a lot of minor garbage collections are performed. If the size is too</p><p>large, then only full garbage collections are performed, which can take a long time to complete.</p><p>Oracle recommends that you keep the size for the young generation greater than 25% and less</p><p>than 50% of the overall heap size.</p><ul><li><p>新生代能容纳所有【并发量 * (请求-响应)】的数据</p></li><li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p></li><li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">XX:MaxTenuringThreshold=threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+PrintTenuringDistribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Desired survivor size 48286924 bytes, new threshold 10 (max 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 1: 28992024 bytes, 28992024 total</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 2: 1366864 bytes, 30358888 total</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 3: 1425912 bytes, 31784800 total</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="55-老年代调优">5.5 老年代调优<a class="hash-link" href="#55-老年代调优" title="Direct link to heading">​</a></h3><p>以 CMS 为例</p><ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经...，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<ul><li>-XX:CMSInitiatingOccupancyFraction=percent</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="56-案例">5.6 案例<a class="hash-link" href="#56-案例" title="Direct link to heading">​</a></h3><ul><li>案例1 Full GC 和 Minor GC频繁</li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/a-java/b-java-jvm/2/readme.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/richardgong1987-learn/docs/a-java/b-java-jvm/1/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">内存结构</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/richardgong1987-learn/docs/a-java/b-java-jvm/3/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">类加载和字节码技术</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#2_垃圾回收pdf" class="table-of-contents__link toc-highlight">2_垃圾回收.pdf</a></li><li><a href="#1如何判断对象可以回收" class="table-of-contents__link toc-highlight">1.如何判断对象可以回收</a><ul><li><a href="#11-引用计数法" class="table-of-contents__link toc-highlight">1.1 引用计数法</a></li><li><a href="#12-可达性分析算法" class="table-of-contents__link toc-highlight">1.2 可达性分析算法</a></li><li><a href="#13-四种引用" class="table-of-contents__link toc-highlight">1.3 四种引用</a></li></ul></li><li><a href="#2垃圾回收算法" class="table-of-contents__link toc-highlight">2.垃圾回收算法</a><ul><li><a href="#21-标记清除" class="table-of-contents__link toc-highlight">2.1 标记清除</a></li><li><a href="#22-标记整理" class="table-of-contents__link toc-highlight">2.2 标记整理</a></li><li><a href="#23-复制" class="table-of-contents__link toc-highlight">2.3 复制</a></li></ul></li><li><a href="#3分代垃圾回收" class="table-of-contents__link toc-highlight">3.分代垃圾回收</a><ul><li><a href="#31-相关-vm-参数" class="table-of-contents__link toc-highlight">3.1 相关 VM 参数</a></li></ul></li><li><a href="#4垃圾回收器" class="table-of-contents__link toc-highlight">4.垃圾回收器</a><ul><li><a href="#41-串行" class="table-of-contents__link toc-highlight">4.1 串行</a></li><li><a href="#42-吞吐量优先" class="table-of-contents__link toc-highlight">4.2 吞吐量优先</a></li><li><a href="#43-响应时间优先" class="table-of-contents__link toc-highlight">4.3 响应时间优先</a></li><li><a href="#44-g1" class="table-of-contents__link toc-highlight">4.4 G1</a></li></ul></li><li><a href="#5垃圾回收调优" class="table-of-contents__link toc-highlight">5.垃圾回收调优</a><ul><li><a href="#51-调优领域" class="table-of-contents__link toc-highlight">5.1 调优领域</a></li><li><a href="#52-确定目标" class="table-of-contents__link toc-highlight">5.2 确定目标</a></li><li><a href="#53-最快的-gc" class="table-of-contents__link toc-highlight">5.3 最快的 GC</a></li><li><a href="#54-新生代调优" class="table-of-contents__link toc-highlight">5.4 新生代调优</a></li><li><a href="#55-老年代调优" class="table-of-contents__link toc-highlight">5.5 老年代调优</a></li><li><a href="#56-案例" class="table-of-contents__link toc-highlight">5.6 案例</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.dcd6332f.js"></script>
<script src="/richardgong1987-learn/assets/js/main.d8e191fe.js"></script>
</body>
</html>