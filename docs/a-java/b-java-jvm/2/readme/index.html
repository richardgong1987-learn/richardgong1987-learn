<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<title data-react-helmet="true">垃圾收回 | 学习大使</title><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/readme"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="垃圾收回 | 学习大使"><meta data-react-helmet="true" name="description" content="2垃圾回收.pdf"><meta data-react-helmet="true" property="og:description" content="2垃圾回收.pdf"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/readme"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/readme" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/a-java/b-java-jvm/2/readme" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.95f9e9dc.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.c594aaae.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.aefe47d8.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java架构师</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/intro">Java架构师学习内容目录</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">java并发编程</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">java-jvm性能调优</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/intro">JVM性能调优学习</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">1.内存结构</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">2.垃圾回收</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/richardgong1987-learn/docs/a-java/b-java-jvm/2/readme">垃圾收回</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">3.类加载和字节码技术</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">4.内存模型</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">java服务架构</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">计算机机科学</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">垃圾收回</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2_垃圾回收pdf"></a><a target="_blank" href="/richardgong1987-learn/assets/files/2_垃圾回收-548b59ea2ffb723023dba9505c9dae1e.pdf">2_垃圾回收.pdf</a><a class="hash-link" href="#2_垃圾回收pdf" title="Direct link to heading">#</a></h2><ol><li><p>如何判断对象可以回收</p></li><li><p>垃圾回收算法</p></li><li><p>分代垃圾回收</p></li><li><p>垃圾回收器</p></li><li><p>垃圾回收调优</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1如何判断对象可以回收"></a>1.如何判断对象可以回收<a class="hash-link" href="#1如何判断对象可以回收" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="11-引用计数法"></a>1.1 引用计数法<a class="hash-link" href="#11-引用计数法" title="Direct link to heading">#</a></h3><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712132244841.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712132244841" src="/richardgong1987-learn/assets/images/image-20200712132244841-d3abc1701865ee988db2bb2c014b235d.png"></a></p><p>代表作:早期的python vm听说是用这种算法的</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="12-可达性分析算法"></a>1.2 可达性分析算法<a class="hash-link" href="#12-可达性分析算法" title="Direct link to heading">#</a></h3><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以</p><p>回收</p><p>哪些对象可以作为 GC Root ?</p><ul><li>System class系列的</li></ul><blockquote><p>如:java.lang.Class下的所有类</p></blockquote><ul><li>Native Stack</li><li>Thread</li><li>Busy Monitor</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="13-四种引用"></a>1.3 四种引用<a class="hash-link" href="#13-四种引用" title="Direct link to heading">#</a></h3><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712134233199.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712134233199" src="/richardgong1987-learn/assets/images/image-20200712134233199-294fe6cf30d9d1cf4b87b72b809db0a7.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1强引用"></a>1.强引用<a class="hash-link" href="#1强引用" title="Direct link to heading">#</a></h4><p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2软引用（softreference）"></a>2.软引用（SoftReference）<a class="hash-link" href="#2软引用（softreference）" title="Direct link to heading">#</a></h4><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用</p><p>对象</p><p>可以配合引用队列来释放软引用自身</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3弱引用（weakreference）"></a>3.弱引用（WeakReference）<a class="hash-link" href="#3弱引用（weakreference）" title="Direct link to heading">#</a></h4><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><p>可以配合引用队列来释放弱引用自身</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4虚引用（phantomreference）"></a>4.虚引用（PhantomReference）<a class="hash-link" href="#4虚引用（phantomreference）" title="Direct link to heading">#</a></h4><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，</p><p>由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5终结器引用（finalreference）"></a>5.终结器引用（FinalReference）<a class="hash-link" href="#5终结器引用（finalreference）" title="Direct link to heading">#</a></h4><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象</p><p>暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize</p><p>方法，第二次 GC 时才能回收被引用对象</p><p>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2垃圾回收算法"></a>2.垃圾回收算法<a class="hash-link" href="#2垃圾回收算法" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="21-标记清除"></a>2.1 标记清除<a class="hash-link" href="#21-标记清除" title="Direct link to heading">#</a></h3><p>定义： Mark Sweep</p><ul><li>速度较快</li><li>会造成内存</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712165945473.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712165945473" src="/richardgong1987-learn/assets/images/image-20200712165945473-8d969d161fe35ad54094d64a9104496a.png"></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="22-标记整理"></a>2.2 标记整理<a class="hash-link" href="#22-标记整理" title="Direct link to heading">#</a></h3><p>定义：Mark Compact</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170023855.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712170023855" src="/richardgong1987-learn/assets/images/image-20200712170023855-09092e6617b26f8f7853c46c94541671.png"></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="23-复制"></a>2.3 复制<a class="hash-link" href="#23-复制" title="Direct link to heading">#</a></h3><p>定义：Copy</p><ul><li>不会有内存碎片</li><li>需要占用双倍内存空间</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170053771.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712170053771" src="/richardgong1987-learn/assets/images/image-20200712170053771-edcca8b37e55a39c81fdcb8d6c7a65ad.png"></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3分代垃圾回收"></a>3.分代垃圾回收<a class="hash-link" href="#3分代垃圾回收" title="Direct link to heading">#</a></h2><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712170422301.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712170422301" src="/richardgong1987-learn/assets/images/image-20200712170422301-d67c525f0832bb4b3677beaa25a9d191.png"></a></p><ul><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的</p><p>对象年龄加 1并且交换 from to</p></li><li><p>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li><li><p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p></li><li><p>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时</p><p>间更长</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="31-相关-vm-参数"></a>3.1 相关 VM 参数<a class="hash-link" href="#31-相关-vm-参数" title="Direct link to heading">#</a></h3><p>含义参数</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712172615432.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712172615432" src="/richardgong1987-learn/assets/images/image-20200712172615432-4a6c4242e62ade9880a2b889acecd62f.png"></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4垃圾回收器"></a>4.垃圾回收器<a class="hash-link" href="#4垃圾回收器" title="Direct link to heading">#</a></h2><ol><li><strong>串行</strong></li></ol><p>单线程</p><p>堆内存较小，适合个人电脑</p><ol><li><strong>吞吐量优先</strong></li></ol><p>多线程</p><p>堆内存较大，多核 cpu</p><p>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高</p><ol><li><strong>响应时间优先</strong></li></ol><p>多线程</p><p>堆内存较大，多核 cpu</p><p>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="41-串行"></a>4.1 串行<a class="hash-link" href="#41-串行" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+UseSerialGC = Serial + SerialOld     其中:Serial使用复制算法.  SerialOld使用标记加整理算法</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182645657.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712182645657" src="/richardgong1987-learn/assets/images/image-20200712182645657-c626951a3582804b60f9a3847c3bed23.png"></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="42-吞吐量优先"></a>4.2 吞吐量优先<a class="hash-link" href="#42-吞吐量优先" title="Direct link to heading">#</a></h3><p>jdk1.8默认使用.</p><p><strong>缺点:</strong> 多核cpu才能发挥其性能</p><p>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</p><p>复制算法 标记加整理算法</p><p>-XX:+UseAdaptiveSizePolicy</p><p>-XX:GCTimeRatio=ratio</p><p>-XX:MaxGCPauseMillis=ms</p><p>-XX:ParallelGCThreads=n</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182842864.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712182842864" src="/richardgong1987-learn/assets/images/image-20200712182842864-64e0c00dfcc2c814fe868e01d93a8b08.png"></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="43-响应时间优先"></a>4.3 响应时间优先<a class="hash-link" href="#43-响应时间优先" title="Direct link to heading">#</a></h3><p>CMS收回器</p><p><strong>缺点:</strong>容易碎片多. 并发会失败</p><p>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</p><p>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</p><p>-XX:CMSInitiatingOccupancyFraction=percent</p><p>-XX:+CMSScavengeBeforeRemark</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712182917164.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712182917164" src="/richardgong1987-learn/assets/images/image-20200712182917164-d90e8c6cf529c701fc379fc575826adf.png"></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="44-g1"></a>4.4 G1<a class="hash-link" href="#44-g1" title="Direct link to heading">#</a></h3><p>吞吐量和响应的折中回收器</p><p><strong>定义：Garbage First</strong></p><ul><li>2004 论文发布</li><li>2009 JDK 6u14 体验</li><li>2012 JDK 7u4 官方支持</li><li>2017 JDK 9 默认</li></ul><p><strong>适用场景</strong></p><p>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</p><p>超大堆内存，会将堆划分为多个大小相等的 Region</p><p>整体上是标记+整理算法，两个区域之间是复制算法</p><p><strong>相关 JVM 参数</strong></p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize=size</p><p>-XX:MaxGCPauseMillis=time</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-g1-垃圾回收阶段"></a>1) G1 垃圾回收阶段<a class="hash-link" href="#1-g1-垃圾回收阶段" title="Direct link to heading">#</a></h4><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712184846275.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712184846275" src="/richardgong1987-learn/assets/images/image-20200712184846275-98e93b28c35eb5dea48d6933920d7cfd.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-young-collection"></a>2) Young Collection<a class="hash-link" href="#2-young-collection" title="Direct link to heading">#</a></h4><ul><li><p>会 STW</p></li><li><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185019409.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712185019409" src="/richardgong1987-learn/assets/images/image-20200712185019409-af0dde0978ea1d1b31da319227655b18.png"></a></p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185005082.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712185005082" src="/richardgong1987-learn/assets/images/image-20200712185005082-eb5bfc55ea565fc99d1bb717468476a4.png"></a></p></li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712185104291.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712185104291" src="/richardgong1987-learn/assets/images/image-20200712185104291-7bab7e9ded1c197807c798bbf2900259.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-young-collection--cm"></a>3) Young Collection + CM<a class="hash-link" href="#3-young-collection--cm" title="Direct link to heading">#</a></h4><p>在 Young GC 时会进行 GC Root 的初始标记</p><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</p><p>-XX:InitiatingHeapOccupancyPercent</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202654480.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712202654480" src="/richardgong1987-learn/assets/images/image-20200712202654480-e4fd99f6d1d156bc78c8cda2f9761a1a.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-mixed-collection"></a>4) Mixed Collection<a class="hash-link" href="#4-mixed-collection" title="Direct link to heading">#</a></h4><p>会对 E、S、O 进行全面垃圾回收</p><p>最终标记（Remark）会 STW</p><p>拷贝存活（Evacuation）会 STW</p><p>-XX:MaxGCPauseMillis=ms</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202711209.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712202711209" src="/richardgong1987-learn/assets/images/image-20200712202711209-54d2ef6154a515d952dea3909446d709.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-full-gc"></a>5) Full GC<a class="hash-link" href="#5-full-gc" title="Direct link to heading">#</a></h4><p><strong>SerialGC</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p><strong>ParallelGC</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p><strong>CMS</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><p><strong>G1</strong></p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6-young-collection-跨代引用"></a>6) Young Collection 跨代引用<a class="hash-link" href="#6-young-collection-跨代引用" title="Direct link to heading">#</a></h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202837130.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712202837130" src="/richardgong1987-learn/assets/images/image-20200712202837130-5c0e5be07c5765a28f6770d90d0049c8.png"></a></p><ul><li>卡表与 Remembered Set</li><li>在引用变更时通过 post-write barrier + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712202926543.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712202926543" src="/richardgong1987-learn/assets/images/image-20200712202926543-4f3f91781ec273f5b78dd26dc231d66f.png"></a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="7-remark"></a>7) Remark<a class="hash-link" href="#7-remark" title="Direct link to heading">#</a></h4><ul><li><p>pre-write barrier + satb_mark_queue</p><p><a href="https://github.com/richardgong1987-learn/learn-jvm/blob/master/images/gc/image-20200712203006661.png" target="_blank" rel="noopener noreferrer"><img alt="image-20200712203006661" src="/richardgong1987-learn/assets/images/image-20200712203006661-921f6bf3741a33d6aa2329b98562e148.png"></a></p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="8-jdk-8u20-字符串去重"></a>8) JDK 8u20 字符串去重<a class="hash-link" href="#8-jdk-8u20-字符串去重" title="Direct link to heading">#</a></h4><ul><li><p>优点：节省大量内存</p></li><li><p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+UseStringDeduplication</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">String s1 = new String(&quot;hello&quot;); // char[]{&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">String s2 = new String(&quot;hello&quot;); // char[]{&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><p>将所有新分配的字符串放入一个队列</p></li><li><p>当新生代回收时，G1并发检查是否有字符串重复</p></li><li><p>如果它们值一样，让它们引用同一个 char[]</p><ul><li>注意，与 String.intern() 不一样</li><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="9-jdk-8u40-并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载<a class="hash-link" href="#9-jdk-8u40-并发标记类卸载" title="Direct link to heading">#</a></h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸</p><p>载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="10-jdk-8u60-回收巨型对象"></a>10) JDK 8u60 回收巨型对象<a class="hash-link" href="#10-jdk-8u60-回收巨型对象" title="Direct link to heading">#</a></h4><p>一个对象大于 region 的一半时，称之为巨型对象</p><p>G1 不会对巨型对象进行拷贝</p><p>回收时被优先考虑</p><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生</p><p>代垃圾回收时处理掉</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="11-jdk-9-并发标记起始时间的调整"></a>11) JDK 9 并发标记起始时间的调整<a class="hash-link" href="#11-jdk-9-并发标记起始时间的调整" title="Direct link to heading">#</a></h4><ul><li><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p></li><li><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</p></li><li><p>JDK 9 可以动态调整</p><ul><li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul><h4></h4></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="12-jdk-9-更高效的回收"></a>12) JDK 9 更高效的回收<a class="hash-link" href="#12-jdk-9-更高效的回收" title="Direct link to heading">#</a></h4><p>预备知识</p><p>掌握 GC 相关的 VM 参数，会基本的空间调整</p><p>掌握相关工具</p><p>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5垃圾回收调优"></a>5.垃圾回收调优<a class="hash-link" href="#5垃圾回收调优" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="51-调优领域"></a>5.1 调优领域<a class="hash-link" href="#51-调优领域" title="Direct link to heading">#</a></h3><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="52-确定目标"></a>5.2 确定目标<a class="hash-link" href="#52-确定目标" title="Direct link to heading">#</a></h3><ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="53-最快的-gc"></a>5.3 最快的 GC<a class="hash-link" href="#53-最快的-gc" title="Direct link to heading">#</a></h3><p>答案是:不发生 GC,才是最快的GC</p><ul><li>查看 FullGC 前后的内存占用，考虑下面几个问题<ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(&quot;select * from 大表 limit n&quot;)</li></ul></li><li>数据表示是否太臃肿？<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏？<ul><li>static Map map =</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="54-新生代调优"></a>5.4 新生代调优<a class="hash-link" href="#54-新生代调优" title="Direct link to heading">#</a></h3><ul><li>新生代的特点<ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价是零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远远低于 Full GC</li></ul></li><li>越大越好吗？</li></ul><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).</p><p>GC is performed in this region more often than in other regions. If the size for the young</p><p>generation is too small, then a lot of minor garbage collections are performed. If the size is too</p><p>large, then only full garbage collections are performed, which can take a long time to complete.</p><p>Oracle recommends that you keep the size for the young generation greater than 25% and less</p><p>than 50% of the overall heap size.</p><ul><li><p>新生代能容纳所有【并发量 * (请求-响应)】的数据</p></li><li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p></li><li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">XX:MaxTenuringThreshold=threshold</span></span><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+PrintTenuringDistribution</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Desired survivor size 48286924 bytes, new threshold 10 (max 10)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 1: 28992024 bytes, 28992024 total</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 2: 1366864 bytes, 30358888 total</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- age 3: 1425912 bytes, 31784800 total</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="55-老年代调优"></a>5.5 老年代调优<a class="hash-link" href="#55-老年代调优" title="Direct link to heading">#</a></h3><p>以 CMS 为例</p><ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经...，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<ul><li>-XX:CMSInitiatingOccupancyFraction=percent</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="56-案例"></a>5.6 案例<a class="hash-link" href="#56-案例" title="Direct link to heading">#</a></h3><ul><li>案例1 Full GC 和 Minor GC频繁</li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/a-java/b-java-jvm/2/readme.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/a-java/b-java-jvm/1/readme"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 内存结构</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/a-java/b-java-jvm/3/readme"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">类加载和字节码技术 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#2_垃圾回收pdf" class="table-of-contents__link">2_垃圾回收.pdf</a></li><li><a href="#1如何判断对象可以回收" class="table-of-contents__link">1.如何判断对象可以回收</a><ul><li><a href="#11-引用计数法" class="table-of-contents__link">1.1 引用计数法</a></li><li><a href="#12-可达性分析算法" class="table-of-contents__link">1.2 可达性分析算法</a></li><li><a href="#13-四种引用" class="table-of-contents__link">1.3 四种引用</a></li></ul></li><li><a href="#2垃圾回收算法" class="table-of-contents__link">2.垃圾回收算法</a><ul><li><a href="#21-标记清除" class="table-of-contents__link">2.1 标记清除</a></li><li><a href="#22-标记整理" class="table-of-contents__link">2.2 标记整理</a></li><li><a href="#23-复制" class="table-of-contents__link">2.3 复制</a></li></ul></li><li><a href="#3分代垃圾回收" class="table-of-contents__link">3.分代垃圾回收</a><ul><li><a href="#31-相关-vm-参数" class="table-of-contents__link">3.1 相关 VM 参数</a></li></ul></li><li><a href="#4垃圾回收器" class="table-of-contents__link">4.垃圾回收器</a><ul><li><a href="#41-串行" class="table-of-contents__link">4.1 串行</a></li><li><a href="#42-吞吐量优先" class="table-of-contents__link">4.2 吞吐量优先</a></li><li><a href="#43-响应时间优先" class="table-of-contents__link">4.3 响应时间优先</a></li><li><a href="#44-g1" class="table-of-contents__link">4.4 G1</a></li></ul></li><li><a href="#5垃圾回收调优" class="table-of-contents__link">5.垃圾回收调优</a><ul><li><a href="#51-调优领域" class="table-of-contents__link">5.1 调优领域</a></li><li><a href="#52-确定目标" class="table-of-contents__link">5.2 确定目标</a></li><li><a href="#53-最快的-gc" class="table-of-contents__link">5.3 最快的 GC</a></li><li><a href="#54-新生代调优" class="table-of-contents__link">5.4 新生代调优</a></li><li><a href="#55-老年代调优" class="table-of-contents__link">5.5 老年代调优</a></li><li><a href="#56-案例" class="table-of-contents__link">5.6 案例</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.c594aaae.js"></script>
<script src="/richardgong1987-learn/assets/js/main.aefe47d8.js"></script>
</body>
</html>