<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">一个方法团灭 LeetCode 股票买卖问题 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="一个方法团灭 LeetCode 股票买卖问题 | 学习大使"><meta data-react-helmet="true" name="description" content="用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。"><meta data-react-helmet="true" property="og:description" content="用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.fd585c74.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.731bdb4a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1>一个方法团灭 LeetCode 股票买卖问题</h1></header><p>用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit(vector&lt;int&gt;&amp; prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(prices.empty()) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int i=1;i&lt;prices.size();++i) {            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        s1 = max(s1, -prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        s2 = max(s2, s1+prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        s3 = max(s3, s2-prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        s4 = max(s4, s3+prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return max(0,s4);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Ff2f977954117e3643323d2eac4c3668f502835d1.png?alt=media" alt="img"></p><p>第一题是只进行一次交易，相当于 <code>k = 1</code>；第二题是不限交易次数，相当于 <code>k = +infinity</code>（正无穷）；第三题是只进行 2 次交易，相当于 <code>k = 2</code>；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><p>如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。</p><p><strong>一、穷举框架</strong></p><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">for 状态1 in 状态1的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for 状态2 in 状态2的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[状态1][状态2][...] = 择优(选择1，选择2...)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 <code>buy</code>, <code>sell</code>, <code>rest</code> 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 <code>sell</code> 必须在 <code>buy</code> 之后，<code>buy</code> 必须在 <code>sell</code> 之后。那么 <code>rest</code> 操作还应该分两种状态，一种是 <code>buy</code> 之后的 <code>rest</code>（持有了股票），一种是 <code>sell</code> 之后的 <code>rest</code>（没有持有股票）。而且别忘了，我们还有交易次数 <code>k</code> 的限制，就是说你 <code>buy</code> 还只能在 <code>k &gt; 0</code> 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 <code>rest</code> 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][0 or 1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n 为天数，大 K 为最多交易数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">此问题共 n × K × 2 种状态，全部穷举就能搞定。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for 0 &lt;= i &lt; n:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for 1 &lt;= k &lt;= K:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for s in {0, 1}:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][k][s] = max(`buy`, `sell`, `rest`)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 <code>dp[n - 1][K][0]</code>，即最后一天，最多允许 <code>K</code> 次交易，最多获得多少利润。读者可能问为什么不是 <code>dp[n - 1][K][1]</code>？因为 <code>dp[n - 1][K][1]</code> 代表到最后一天手上还持有股票，<code>dp[n - 1][K][0]</code> 表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><p><strong>二、状态转移框架</strong></p><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F298b4971971d6e850923f64ab74792b86aa5c668.png?alt=media" alt="img"></p><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              max(   选择 `rest`  ,             选择 `sell`      )</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>解释：今天我没有持有股票，有两种可能：</p><p>要么是我昨天就没有持有，然后今天选择 <code>rest</code>，所以我今天还是没有持有；</p><p>要么是我昨天持有股票，但是今天我 <code>sell</code> 了，所以我今天没有持有股票了。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              max(   选择 `rest`  ,           选择 `buy`         )</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>解释：今天我持有着股票，有两种可能：</p><p>要么我昨天就持有着股票，然后今天选择 <code>rest</code>，所以我今天还持有着股票；</p><p>要么我昨天本没有持有，但今天我选择 <code>buy</code>，所以今天我就持有股票了。</p><p>这个解释应该很清楚了，如果 <code>buy</code>，就要从利润中减去 <code>prices[i]</code>，如果 <code>sell</code>，就要给利润增加 <code>prices[i]</code>。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 <code>buy</code> 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 <code>sell</code> 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[-1][k][0] = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[-1][k][1] = -infinity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：还没开始的时候，是不可能持有股票的。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0][0] = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0][1] = -infinity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：不允许交易的情况下，是不可能持有股票的。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>把上面的状态转移方程总结一下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">base case：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[-1][k][0] = dp[i][0][0] = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[-1][k][1] = dp[i][0][1] = -infinity</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">状态转移方程：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><p><strong>三、秒杀题目</strong></p><p><strong>第一题，k = 1</strong></p><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            = max(dp[i-1][1][1], -prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">可以进行进一步化简去掉所有 k：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1] = max(dp[i-1][1], -prices[i])</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>直接写出代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][] dp = new int[n][2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[n - 1][0];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>显然 <code>i = 0</code> 时 <code>i-1</code> 是不合法的索引，这是因为我们没有对 <code>i</code> 的 base case 进行处理。可以这样处理：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i - 1 == -1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][0] = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 解释：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //   dp[i][0] </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // = max(0, -infinity + prices[i]) = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][1] = -prices[i];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //解释：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //   dp[i][1] </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // = max(-infinity, 0 - prices[i]) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // = -prices[i]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[n - 1][0];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 <code>dp</code> 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// k == 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_k_1(int[] prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><p><strong>第二题，k = +infinity</strong></p><p>如果 <code>k</code> 为正无穷，那么就可以认为 <code>k</code> 和 <code>k - 1</code> 是一样的。可以这样改写框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>直接翻译成代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_k_inf(int[] prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp = dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>第三题，k = +infinity with cooldown</strong></p><p>每次 <code>sell</code> 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：第 i 天选择 `buy` 的时候，要从 i-2 的状态转移，而不是 i-1 。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>翻译成代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_with_cool(int[] prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_pre_0 = 0; // 代表 dp[i-2][0]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp = dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_pre_0 = temp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>第四题，k = +infinity with fee</strong></p><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">解释：相当于买入股票的价格升高了。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>直接翻译成代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_with_fee(int[] prices, int fee) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp = dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp_i_0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>第五题，k = 2</strong></p><p><code>k = 2</code> 和前面题目的情况稍微不同，因为上面的情况都和 <code>k</code> 的关系不太大。要么 <code>k</code> 是正无穷，状态转移和 <code>k</code> 没关系了；要么 <code>k = 1</code>，跟 <code>k = 0</code> 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 <code>k = 2</code> 和后面要讲的 <code>k</code> 是任意正整数的情况中，对 <code>k</code> 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">原始的状态转移方程，没有可化简的地方</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int k = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][][] dp = new int[n][k + 1][2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i - 1 == -1) { /* 处理一下 base case*/ }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[n - 1][k][0];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 <code>k</code> 都被化简掉了。</p><p>比如说第一题，<code>k = 1</code> 时的代码框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][] dp = new int[n][2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[n - 1][0];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>但当 <code>k = 2</code> 时，由于没有消掉 <code>k</code> 的影响，所以必须要对 <code>k</code> 进行穷举：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int max_k = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][][] dp = new int[n][max_k + 1][2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int k = max_k; k &gt;= 1; k--) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i - 1 == -1) { /*处理 base case */ }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 穷举了 n × max_k × 2 个状态，正确。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[n - 1][max_k][0];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>PS：这里肯定会有读者疑惑，**</strong><code>k</code>** <strong>的 base case 是 0，按理说应该从</strong> <strong><code>k = 1, k++</code></strong> <strong>这样穷举状态</strong> <strong><code>k</code></strong> <strong>才对？而且如果你真的这样从小到大遍历</strong> <strong><code>k</code>**</strong>，提交发现也是可以的**。</p><p>这个疑问很正确，因为我们前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye/zui-you-zi-jie-gou" target="_blank" rel="noopener noreferrer">动态规划答疑篇</a> 有介绍 <code>dp</code> 数组的遍历顺序是怎么确定的，主要是根据 base case，以 base case 为起点，逐步向结果靠近。</p><p>但为什么我从大到小遍历 <code>k</code> 也可以正确提交呢？因为你注意看，<code>dp[i][k]</code> 不会依赖 <code>dp[i][k - 1]</code>，而是依赖 <code>dp[i - 1][k - 1]</code>，对于 <code>dp[i - 1][...]</code>，都是已经计算出来的，所以不管你是 <code>k = max_k, k--</code>，还是 <code>k = 1, k++</code>，都是可以得出正确答案的。</p><p>那为什么我使用 <code>k = max_k, k--</code> 的方式呢？因为这样符合语义。</p><p>你买股票，初始的「状态」是什么？应该是从第 0 天开始，因为还没有进行买卖，所以最大交易次数 <code>k</code> 应该是 <code>max_k</code>，而随着对状态的穷举，交易次数上限 <code>k</code> 应该不断减少，这样一想，<code>k = max_k, k--</code> 的方式是比较合乎我们理解的。</p><p>当然，这里 <code>k</code> 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_k_2(int[] prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int price : prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp_i11 = Math.max(dp_i11, -price);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp_i20;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。</p><p><strong>第六题，k = any integer</strong></p><p>有了上一题 <code>k = 2</code> 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 <code>k</code> 值会非常大，<code>dp</code> 数组太大了。现在想想，交易次数 <code>k</code> 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 <code>k</code> 应该不超过 <code>n/2</code>，如果超过，就没有约束作用了，相当于 <code>k = +infinity</code>。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int maxProfit_k_any(int max_k, int[] prices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = prices.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (max_k &gt; n / 2) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return maxProfit_k_inf(prices);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][][] dp = new int[n][max_k + 1][2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int k = max_k; k &gt;= 1; k--) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (i - 1 == -1) { /* 处理 base case */ }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp[n - 1][max_k][0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>至此，6 道题目通过一个状态转移方程全部解决。</p><p><strong>四、最后总结</strong></p><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 <code>dp</code> 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 一首把滑动窗口算法算法诗</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">一个方法团灭 LeetCode 打家劫舍问题 »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.fd585c74.js"></script>
<script src="/richardgong1987-learn/assets/js/main.731bdb4a.js"></script>
</body>
</html>