<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">手把手带你刷二叉树（第一期） | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="手把手带你刷二叉树（第一期） | 学习大使"><meta data-react-helmet="true" name="description" content="举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。"><meta data-react-helmet="true" property="og:description" content="举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.355ae127.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.e4c628bc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1>手把手带你刷二叉树（第一期）</h1></header><header><h1>一、二叉树的重要性</h1></header><p>举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？<strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了</strong>。</p><p>为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：</p><p>快速排序的逻辑是，若要对 <code>nums[lo..hi]</code> 进行排序，我们先找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>，然后递归地去 <code>nums[lo..p-1]</code> 和 <code>nums[p+1..hi]</code> 中寻找新的分界点，最后整个数组就被排序了。</p><p>快速排序的代码框架如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void sort(int[] nums, int lo, int hi) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****** 前序遍历位置 ******/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过交换元素构建分界点 p</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int p = partition(nums, lo, hi);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /************************/</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, lo, p - 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, p + 1, hi);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？</p><p>再说说归并排序的逻辑，若要对 <code>nums[lo..hi]</code> 进行排序，我们先对 <code>nums[lo..mid]</code> 排序，再对 <code>nums[mid+1..hi]</code> 排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p><p>归并排序的代码框架如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void sort(int[] nums, int lo, int hi) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mid = (lo + hi) / 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, lo, mid);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums, mid + 1, hi);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****** 后序遍历位置 ******/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 合并两个排好序的子数组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    merge(nums, lo, mid, hi);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /************************/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。</p><p>如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能写出算法了。</p><p>说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题，<strong>所以本文和后续的</strong> <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/er-cha-shu-xi-lie-2" target="_blank" rel="noopener noreferrer"><strong>手把手带你刷二叉树（第二期）</strong></a> <strong>以及</strong> <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/er-cha-shu-xi-lie-3" target="_blank" rel="noopener noreferrer"><strong>手把手刷二叉树（第三期）</strong></a><strong>，我们直接上几道比较有意思，且能体现出递归算法精妙的二叉树题目，东哥手把手教你怎么用算法框架搞定它们</strong>。</p><header><h1>二、写递归算法的秘诀</h1></header><p>我们前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/gong-gong-zu-xian" target="_blank" rel="noopener noreferrer">二叉树的最近公共祖先</a> 写过，<strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节</strong>。</p><p>怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义：count(root) 返回以 root 为根的树有多少节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int count(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自己加上子树的节点数就是整棵树的节点数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 1 + count(root.left) + count(root.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个问题非常简单，大家应该都会写这段代码，<code>root</code> 本身就是一个节点，加上左右子树的节点数就是以 <code>root</code> 为根的树的节点总数。</p><p>左右子树的节点数怎么算？其实就是计算根为 <code>root.left</code> 和 <code>root.right</code> 两棵树的节点数呗，按照定义，递归调用 <code>count</code> 函数即可算出来。</p><p><strong>写树相关的算法，简单说就是，先搞清楚当前</strong> <strong><code>root</code></strong> <strong>节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</p><p>所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。</p><p>我们接下来看几道算法题目实操一下。</p><header><h1>三、算法实践</h1></header><p><strong>第一题、翻转二叉树</strong></p><p>我们先从简单的题开始，看看力扣第 226 题「翻转二叉树」，输入一个二叉树根节点 <code>root</code>，让你把整棵树镜像翻转，比如输入的二叉树如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">     4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /   \</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  2     7</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> / \   / \</span></span><span class="token-line" style="color:#393A34"><span class="token plain">1   3 6   9</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>算法原地翻转二叉树，使得以 <code>root</code> 为根的树变成：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">     4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /   \</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  7     2</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> / \   / \</span></span><span class="token-line" style="color:#393A34"><span class="token plain">9   6 3   1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过观察，<strong>我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树</strong>。</p><p>可以直接写出解法代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 将整棵树的节点翻转</span></span><span class="token-line" style="color:#393A34"><span class="token plain">TreeNode invertTree(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**** 前序遍历位置 ****/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // root 节点需要交换它的左右子节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TreeNode tmp = root.left;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    root.left = root.right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    root.right = tmp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 让左右子节点继续翻转它们的子节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    invertTree(root.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    invertTree(root.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这道题目比较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。</p><p>值得一提的是，如果把交换左右子节点的代码复制粘贴到后序遍历的位置也是可以的，但是直接放到中序遍历的位置是不行的，请你想一想为什么？这个应该不难想到，我会把答案置顶在公众号留言区。</p><p>首先讲这道题目是想告诉你，<strong>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情</strong>。</p><p>这种洞察力需要多刷题训练，我们看下一道题。</p><p><strong>第二题、填充二叉树节点的右侧指针</strong></p><p>这是力扣第 116 题，看下题目：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fedef677b912155ed5f7ae079f037aebde6dc0999.png?alt=media" alt="img"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Node connect(Node root);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>题目的意思就是把二叉树的每一层节点都用 <code>next</code> 指针连接起来：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fec1ebbe6e2aa7a74a946d4d13ebfab3c840fecf4.png?alt=media" alt="img"></p><p>而且题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 <code>next</code> 指针会指向 <code>null</code>，其他节点的右侧一定有相邻的节点。</p><p>这道题怎么做呢？把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？</p><p>我们可以模仿上一道题，写出如下代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Node connect(Node root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null || root.left == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    root.left.next = root.right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connect(root.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connect(root.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样其实有很大问题，再看看这张图：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fec1ebbe6e2aa7a74a946d4d13ebfab3c840fecf4.png?alt=media" alt="img"></p><p>节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。</p><p>回想刚才说的，<strong>二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情</strong>，但是如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。</p><p>那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 主函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Node connect(Node root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectTwoNode(root.left, root.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 辅助函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void connectTwoNode(Node node1, Node node2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node1 == null || node2 == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**** 前序遍历位置 ****/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将传入的两个节点连接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    node1.next = node2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接相同父节点的两个子节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectTwoNode(node1.left, node1.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectTwoNode(node2.left, node2.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接跨越父节点的两个子节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectTwoNode(node1.right, node2.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，<code>connectTwoNode</code> 函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。</p><p><strong>第三题、将二叉树展开为链表</strong></p><p>这是力扣第 114 题，看下题目：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F65841b408918dfcfb84c830cd87bda1c387388a0.png?alt=media" alt="img"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void flatten(TreeNode root);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们尝试给出这个函数的定义：</p><p><strong>给</strong> <strong><code>flatten</code></strong> <strong>函数输入一个节点</strong> <strong><code>root</code>**</strong>，那么以** <strong><code>root</code></strong> <strong>为根的二叉树就会被拉平为一条链表</strong>。</p><p>我们再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：</p><p>1、将 <code>root</code> 的左子树和右子树拉平。</p><p>2、将 <code>root</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fd11ee940259be5f710700e2ed073068a64bf5746.jpeg?alt=media" alt="img"></p><p>上面三步看起来最难的应该是第一步对吧，如何把 <code>root</code> 的左右子树拉平？其实很简单，按照 <code>flatten</code> 函数的定义，对 <code>root</code> 的左右子树递归调用 <code>flatten</code> 函数即可：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义：将以 root 为根的树拉平为链表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void flatten(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    flatten(root.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    flatten(root.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**** 后序遍历位置 ****/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1、左右子树已经被拉平成一条链表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TreeNode left = root.left;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TreeNode right = root.right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2、将左子树作为右子树</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    root.left = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    root.right = left;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3、将原先的右子树接到当前右子树的末端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TreeNode p = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (p.right != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p = p.right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.right = right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>你看，这就是递归的魅力，你说 <code>flatten</code> 函数是怎么把左右子树拉平的？说不清楚，但是只要知道 <code>flatten</code> 的定义如此，相信这个定义，让 <code>root</code> 做它该做的事情，然后 <code>flatten</code> 函数就会按照定义工作。另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。</p><p>至此，这道题也解决了，我们旧文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye/k-ge-yi-zu-fan-zhuan-lian-biao" target="_blank" rel="noopener noreferrer">k个一组翻转链表</a> 的递归思路和本题也有一些类似。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 单链表的六大解题套路</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">经典动态规划：0-1 背包问题 »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.355ae127.js"></script>
<script src="/richardgong1987-learn/assets/js/main.e4c628bc.js"></script>
</body>
</html>