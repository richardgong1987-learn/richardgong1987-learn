<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">单链表的六大解题套路 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="单链表的六大解题套路 | 学习大使"><meta data-react-helmet="true" name="description" content="这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题："><meta data-react-helmet="true" property="og:description" content="这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题："><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.fd9d2b8e.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.279dec3d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1>单链表的六大解题套路</h1></header><header><h1>合并两个有序链表</h1></header><p>这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fc9022fe85680bbb367d283c802e9f537173d4b6e.jpg?alt=media" alt="img"></p><p>给你输入两个有序链表，请你把他俩合并成一个新的有序链表，函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode mergeTwoLists(ListNode l1, ListNode l2);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这题比较简单，我们直接看解法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode mergeTwoLists(ListNode l1, ListNode l2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 虚拟头结点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode dummy = new ListNode(-1), p = dummy;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode p1 = l1, p2 = l2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (p1 != null &amp;&amp; p2 != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 比较 p1 和 p2 两个指针</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将值较小的的节点接到 p 指针</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p1.val &gt; p2.val) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            p.next = p2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            p2 = p2.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            p.next = p1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            p1 = p1.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // p 指针不断前进</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p = p.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (p1 != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.next = p1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (p2 != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.next = p2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dummy.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们的 while 循环每次比较 <code>p1</code> 和 <code>p2</code> 的大小，把较小的节点接到结果链表上：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F50434668ec8a255030aa7b068d2465cb50fb6189.gif?alt=media" alt="img"></p><p>这个算法的逻辑类似于「拉拉链」，<code>l1, l2</code> 类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并。</p><p><strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是</strong> <strong><code>dummy</code></strong> <strong>节点</strong>。你可以试试，如果不使用 <code>dummy</code> 虚拟节点，代码会复杂很多，而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p><header><h1>合并 k 个有序链表</h1></header><p>看下力扣第 23 题「合并K个升序链表」：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F1425068a2e96deebbc1cca01a3cc4279bb429e76.jpg?alt=media" alt="img"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode mergeKLists(ListNode[] lists);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>合并 <code>k</code> 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 <code>k</code> 个节点中的最小节点，接到结果链表上？</p><p>这里我们就要用到 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/er-cha-dui-xiang-jie-shi-xian-you-xian-ji-dui-lie" target="_blank" rel="noopener noreferrer">优先级队列（二叉堆）</a> 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode mergeKLists(ListNode[] lists) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (lists.length == 0) return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 虚拟头结点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode dummy = new ListNode(-1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode p = dummy;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 优先级队列，最小堆</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lists.length, (a, b)-&gt;(a.val - b.val));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将 k 个链表的头结点加入最小堆</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ListNode head : lists) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (head != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(head);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取最小节点，接到结果链表中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ListNode node = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.next = node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node.next != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            pq.add(node.next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // p 指针不断前进</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p = p.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dummy.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个算法是面试常考题，它的时间复杂度是多少呢？</p><p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是</strong> <strong><code>O(Nlogk)</code>**</strong>，其中** <strong><code>k</code></strong> <strong>是链表的条数，**</strong><code>N</code>** <strong>是这些链表的节点总数</strong>。</p><header><h1>单链表的倒数第 k 个节点</h1></header><p>从前往后寻找单链表的第 <code>k</code> 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 <code>k</code> 个节点呢？</p><p>那你可能说，假设链表有 <code>n</code> 个节点，倒数第 <code>k</code> 个节点就是正数第 <code>n - k</code> 个节点，不也是一个 for 循环的事儿吗？</p><p>是的，但是算法题一般只给你一个 <code>ListNode</code> 头结点代表一条单链表，你不能直接得出这条链表的长度 <code>n</code>，而需要先遍历一遍链表算出 <code>n</code> 的值，然后再遍历链表计算第 <code>n - k</code> 个节点。</p><p>也就是说，这个解法需要遍历两次链表才能得到出倒数第 <code>k</code> 个节点。</p><p>那么，我们能不能<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。</p><p>这个解法就比较巧妙了，假设 <code>k = 2</code>，思路如下：</p><p>首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F1cfd24dde5e0e88203c3ce38a70bdcb886b71b0f.jpeg?alt=media" alt="img"></p><p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p><p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F084e1816ed7d879121ea3c3db82c0d8987582f3f.jpeg?alt=media" alt="img"></p><p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时走了 <code>n - k</code> 步，<code>p2</code> 也走了 <code>n - k</code> 步，也就是链表的倒数第 <code>k</code> 个节点：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fbc03d1911306257bc3bd2626f3b85bfb5811d8bd.jpeg?alt=media" alt="img"></p><p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p><p>上述逻辑的代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 返回链表的倒数第 k 个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ListNode findFromEnd(ListNode head, int k) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode p1 = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // p1 先走 k 步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; k; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p1 = p1.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode p2 = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // p1 和 p2 同时走 n - k 步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (p1 != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p2 = p2.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        p1 = p1.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // p2 现在指向第 n - k 个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return p2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 <code>O(N)</code>，但上述这个算法更有技巧性。</p><p>很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「删除链表的倒数第 N 个结点」：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F6e083a817d52a38f0b2a76d063141a9b848e4219.jpg?alt=media" alt="img"></p><p>我们直接看解法代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 主函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public ListNode removeNthFromEnd(ListNode head, int n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 虚拟头结点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode dummy = new ListNode(-1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dummy.next = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode x = findFromEnd(dummy, n + 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删掉倒数第 n 个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.next = x.next.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dummy.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private ListNode findFromEnd(ListNode head, int k) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 代码见上文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个逻辑就很简单了，要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用，可以用我们实现的 <code>findFromEnd</code> 来操作。</p><p>不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。</p><p>但有了我们虚拟节点 <code>dummy</code> 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</p><header><h1>单链表的中点</h1></header><p>这个技巧在前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-4/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener noreferrer">双指针技巧汇总</a> 写过，如果看过的读者可以跳过。</p><p>力扣第 876 题「链表的中间结点」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 <code>n</code>，常规方法也是先遍历链表计算 <code>n</code>，再遍历一次得到第 <code>n / 2</code> 个节点，也就是中间节点。</p><p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：</p><p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。</p><p><strong>每当慢指针</strong> <strong><code>slow</code></strong> <strong>前进一步，快指针</strong> <strong><code>fast</code></strong> <strong>就前进两步，这样，当</strong> <strong><code>fast</code></strong> <strong>走到链表末尾时，**</strong><code>slow</code>** <strong>就指向了链表中点</strong>。</p><p>上述思路的代码实现如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode middleNode(ListNode head) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 快慢指针初始化指向 head</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode slow = head, fast = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 快指针走到末尾时停止</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (fast != null &amp;&amp; fast.next != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 慢指针走一步，快指针走两步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow = slow.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fast = fast.next.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 慢指针指向中点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return slow;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p><p>另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p><header><h1>判断链表是否包含环</h1></header><p>这个技巧也在前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-4/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener noreferrer">双指针技巧汇总</a> 写过，如果看过的读者可以跳过。</p><p>判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：</p><p>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。</p><p>如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。</p><p>只需要把寻找链表中点的代码稍加修改就行了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">boolean hasCycle(ListNode head) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 快慢指针初始化指向 head</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode slow = head, fast = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 快指针走到末尾时停止</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (fast != null &amp;&amp; fast.next != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 慢指针走一步，快指针走两步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow = slow.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fast = fast.next.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 快慢指针相遇，说明含有环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (slow == fast) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不包含环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？</p><p>这里简单提一下解法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode detectCycle(ListNode head) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode fast, slow;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    fast = slow = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (fast != null &amp;&amp; fast.next != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fast = fast.next.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow = slow.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (fast == slow) break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 上面的代码类似 hasCycle 函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fast == null || fast.next == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // fast 遇到空指针说明没有环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重新指向头结点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    slow = head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 快慢指针同步前进，相交点就是环起点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (slow != fast) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fast = fast.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        slow = slow.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return slow;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p><p>前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-4/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener noreferrer">双指针技巧汇总</a> 详细解释了其中的原理，这里简单说一下。</p><p>我们假设快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F87b533c20312b343bc76402d886046a5f9ac08d4.jpeg?alt=media" alt="img"></p><p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。</p><p>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走k步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fb08bb68bdbb926df47ef47f485badb0e3e38ca83.jpeg?alt=media" alt="img"></p><p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p><header><h1>两个链表是否相交</h1></header><p>这个问题有意思，也是力扣第 160 题「相交链表」函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode getIntersectionNode(ListNode headA, ListNode headB);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>给你输入两个链表的头结点 <code>headA</code> 和 <code>headB</code>，这两个链表可能存在相交。</p><p>如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。</p><p>比如题目给我们举的例子，如果输入的两个链表如下图：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Facbae058e63f1202b0235eb501143c6d83d8fb6b.png?alt=media" alt="img"></p><p>那么我们的算法应该返回 <code>c1</code> 这个节点。</p><p>这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p><p>如果不用额外的空间，只使用两个指针，你如何做呢？</p><p>难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Ffc1b2f5ff3376a82033f51dd78d1e3426a24fd0a.jpeg?alt=media" alt="img"></p><p>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p><p><strong>所以，解决这个问题的关键是，通过某些方式，让</strong> <strong><code>p1</code></strong> <strong>和</strong> <strong><code>p2</code></strong> <strong>能够同时到达相交节点</strong> <strong><code>c1</code></strong>。</p><p>所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p><p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F638130d871728f7b2859e07cbcbad6597011ab73.jpeg?alt=media" alt="img"></p><p>那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？</p><p>这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 null 空指针嘛，可以正确返回 null。</p><p>按照这个思路，可以写出如下代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ListNode getIntersectionNode(ListNode headA, ListNode headB) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ListNode p1 = headA, p2 = headB;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (p1 != p2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p1 == null) p1 = headB;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else            p1 = p1.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p2 == null) p2 = headA;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else            p2 = p2.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return p1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，这道题就解决了，空间复杂度为 <code>O(1)</code>，时间复杂度为 <code>O(N)</code>。</p><p>以上就是单链表的所有技巧，希望对你有启发。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 一个函数秒杀 2Sum 3Sum 4Sum 问题</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">手把手带你刷二叉树（第一期） »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.fd9d2b8e.js"></script>
<script src="/richardgong1987-learn/assets/js/main.279dec3d.js"></script>
</body>
</html>