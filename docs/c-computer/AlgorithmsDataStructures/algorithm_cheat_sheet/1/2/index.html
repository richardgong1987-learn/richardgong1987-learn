<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">动态规划解题套路框架 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="动态规划解题套路框架 | 学习大使"><meta data-react-helmet="true" name="description" content="首先，动态规划问题的一般形式就是求最值"><meta data-react-helmet="true" property="og:description" content="首先，动态规划问题的一般形式就是求最值"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.53345af5.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.0a3156e5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>动态规划解题套路框架</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="首先，动态规划问题的一般形式就是求最值"></a>首先，动态规划问题的一般形式就是求最值<a class="hash-link" href="#首先，动态规划问题的一般形式就是求最值" title="Direct link to heading">#</a></h2><p>动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如,求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离</p><p>既然是要求最值，核心问题是什么？</p><p><strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。</p><p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong></p><p>按上面的套路走，最后的结果就可以套这个框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly python"><pre tabindex="0" class="prism-code language-python codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 初始化 base case</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> base</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 进行状态转移</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> 状态</span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> 状态</span><span class="token number" style="color:#36acaa">1</span><span class="token plain">的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> 状态</span><span class="token number" style="color:#36acaa">2</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> 状态</span><span class="token number" style="color:#36acaa">2</span><span class="token plain">的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">状态</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">状态</span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> 求最值</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">选择</span><span class="token number" style="color:#36acaa">1</span><span class="token plain">，选择</span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="一、斐波那契数列"></a>一、斐波那契数列<a class="hash-link" href="#一、斐波那契数列" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="1、暴力递归"></a>1、暴力递归<a class="hash-link" href="#1、暴力递归" title="Direct link to heading">#</a></h3><p>斐波那契数列的数学形式就是递归</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int fib(int N) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (N == 1 || N == 2) return 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fib(N - 1) + fib(N - 2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p><p><img alt="1" src="/richardgong1987-learn/assets/images/1-94d8162d27d521db0670f1d30770754e.jpeg"></p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间"></a>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间<a class="hash-link" href="#递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间" title="Direct link to heading">#</a></h4><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="2、带备忘录的递归解法"></a>2、带备忘录的递归解法<a class="hash-link" href="#2、带备忘录的递归解法" title="Direct link to heading">#</a></h3><p>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public int fib(int N) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 备忘录全初始化为 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] memo = new int[N + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 进行带备忘录的递归</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return helper(memo, N);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private int helper(int[] memo, int n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == 0 || n == 1) return n;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 已经计算过，不用再计算了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (memo[n] != 0) return memo[n];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return memo[n];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img alt="2" src="/richardgong1987-learn/assets/images/2-b590ef886609b474d3ed8cbeb8d255ce.jpeg"></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img alt="3" src="/richardgong1987-learn/assets/images/3-279fd612fae2c5b0ea448d16b8a0a7a7.jpeg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。"></a>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。<a class="hash-link" href="#递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。" title="Direct link to heading">#</a></h4><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> ... <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。</p><p>带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="3、dp-数组的迭代解法"></a>3、dp 数组的迭代解法<a class="hash-link" href="#3、dp-数组的迭代解法" title="Direct link to heading">#</a></h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public int fib(int N) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (N == 0) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] dp = new int[N + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[0] = 0; dp[1] = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 状态转移</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 2; i &lt;= N; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i] = dp[i - 1] + dp[i - 2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp[N];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img alt="4" src="/richardgong1987-learn/assets/images/4-79addc982ef657f4072107e765accebe.jpeg"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img alt="fib" src="data:image/png;base64,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"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着<strong>暴力解法</strong>。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 <strong>O(1)</strong>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int fib(int n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n &lt; 1) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == 2 || n == 1) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int prev = 1, curr = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 3; i &lt;= n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sum = prev + curr;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev = curr;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        curr = sum;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return curr;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，<strong>动态规划</strong>的另一个<strong>重要特性</strong> <strong>「最优子结构」</strong>，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="二、凑零钱问题"></a>二、凑零钱问题<a class="hash-link" href="#二、凑零钱问题" title="Direct link to heading">#</a></h2><p>题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// coins 中是可选硬币面值，amount 是目标金额</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int coinChange(int[] coins, int amount);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="1、暴力递归-1"></a>1、暴力递归<a class="hash-link" href="#1、暴力递归-1" title="Direct link to heading">#</a></h3><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong></p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪码框架</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public int coinChange(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 题目要求的最终结果是 dp(amount)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp(coins, amount)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int dp(int[] coins, int n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 做选择，选择需要硬币最少的那个结果</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int coin : coins) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = min(res, 1 + dp(n - coin))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public int coinChange(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 题目要求的最终结果是 dp(amount)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp(coins, amount)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private int dp(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (amount == 0) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (amount &lt; 0) return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = Integer.MAX_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int coin : coins) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 计算子问题的结果</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int subProblem = dp(coins, amount - coin);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 子问题无解则跳过</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (subProblem == -1) continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在子问题中选择最优解，然后加一</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = Math.min(res, subProblem + 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res == Integer.MAX_VALUE ? -1 : res;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" alt="img"></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F11389aca27fca8bf28578565fcd46e2c4b051e91.jpg?alt=media" alt="img"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int[] memo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public int coinChange(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    memo = new int[amount + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // dp 数组全都初始化为特殊值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(memo, -666);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp(coins, amount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private int dp(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (amount == 0) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (amount &lt; 0) return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 查备忘录，防止重复计算</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (memo[amount] != -666)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return memo[amount];</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = Integer.MAX_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int coin : coins) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 计算子问题的结果</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int subProblem = dp(coins, amount - coin);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 子问题无解则跳过</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (subProblem == -1) continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在子问题中选择最优解，然后加一</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = Math.min(res, subProblem + 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 把计算结果存入备忘录</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return memo[amount];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public int coinChange(int[] coins, int amount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] dp = new int[amount + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组大小为 amount + 1，初始值也为 amount + 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(dp, amount + 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp[0] = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 外层 for 循环在遍历所有状态的所有取值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; dp.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 内层 for 循环在求所有选择的最小值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int coin : coins) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 子问题无解，跳过</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (i - coin &lt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (dp[amount] == amount + 1) ? -1 : dp[amount];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F17a588ce985b456232062703d025551175d57895.jpg?alt=media" alt="img"></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 <code>Integer.MAX_VALUE</code> 呢？因为后面有 <code>dp[i - coin] + 1</code>，这就会导致整型溢出。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="三、最后总结"></a>三、最后总结<a class="hash-link" href="#三、最后总结" title="Direct link to heading">#</a></h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 经典动态规划：0-1 背包问题</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">回溯算法解题套路框架 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#首先，动态规划问题的一般形式就是求最值" class="table-of-contents__link">首先，动态规划问题的一般形式就是求最值</a></li><li><a href="#一、斐波那契数列" class="table-of-contents__link">一、斐波那契数列</a><ul><li><a href="#1、暴力递归" class="table-of-contents__link">1、暴力递归</a></li><li><a href="#2、带备忘录的递归解法" class="table-of-contents__link">2、带备忘录的递归解法</a></li><li><a href="#3、dp-数组的迭代解法" class="table-of-contents__link">3、dp 数组的迭代解法</a></li></ul></li><li><a href="#二、凑零钱问题" class="table-of-contents__link">二、凑零钱问题</a><ul><li><a href="#1、暴力递归-1" class="table-of-contents__link">1、暴力递归</a></li></ul></li><li><a href="#三、最后总结" class="table-of-contents__link">三、最后总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.53345af5.js"></script>
<script src="/richardgong1987-learn/assets/js/main.0a3156e5.js"></script>
</body>
</html>