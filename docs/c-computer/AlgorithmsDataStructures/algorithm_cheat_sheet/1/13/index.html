<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">经典动态规划：0-1 背包问题 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="经典动态规划：0-1 背包问题 | 学习大使"><meta data-react-helmet="true" name="description" content="后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。"><meta data-react-helmet="true" property="og:description" content="后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.fd9d2b8e.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.279dec3d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1>经典动态规划：0-1 背包问题</h1></header><p>后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。</p><p>今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题。描述：</p><p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F9a5d7fb6436e5e4278b90cf201b78dcee49109a9.png?alt=media" alt="img"></p><p>举个简单的例子，输入如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">N = 3, W = 4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">wt = [2, 1, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val = [4, 2, 3]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>算法返回 6，选择前两件物品装进背包，总重量 3 小于 <code>W</code>，可以获得最大价值 6。</p><p>题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。</p><p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener noreferrer">动态规划详解</a> 中的套路，直接走流程就行了。</p><header><h1>动规标准套路</h1></header><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的。</p><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p><p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p><p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">for 状态1 in 状态1的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for 状态2 in 状态2的所有取值：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[状态1][状态2][...] = 择优(选择1，选择2...)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>PS：此框架出自历史文章 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-4/tuan-mie-gu-piao-wen-ti" target="_blank" rel="noopener noreferrer">团灭 LeetCode 股票问题</a>。</p><p><strong>第二步要明确</strong> <strong><code>dp</code></strong> <strong>数组的定义</strong>。</p><p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 <code>dp</code> 数组。</p><p><code>dp[i][w]</code> 的定义如下：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code>。</p><p>比如说，如果 <code>dp[3][5] = 6</code>，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p><p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种套路都被扒得清清楚楚了。</p><p>根据这个定义，我们想求的最终答案就是 <code>dp[N][W]</code>。base case 就是 <code>dp[0][..] = dp[..][0] = 0</code>，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p><p>细化上面的框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int[][] dp[N+1][W+1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[0][..] = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dp[..][0] = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in [1..N]:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for w in [1..W]:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][w] = max(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            把物品 i 装进背包,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            不把物品 i 装进背包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[N][W]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>简单说就是，上面伪码中「把物品 <code>i</code> 装进背包」和「不把物品 <code>i</code> 装进背包」怎么用代码体现出来呢？</p><p>这就要结合对 <code>dp</code> 数组的定义，看看这两种选择会对状态产生什么影响：</p><p>先重申一下刚才我们的 <code>dp</code> 数组的定义：</p><p><code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。</p><p><strong>如果你没有把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，那么很显然，最大价值 <code>dp[i][w]</code> 应该等于 <code>dp[i-1][w]</code>，继承之前的结果。</p><p><strong>如果你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，那么 <code>dp[i][w]</code> 应该等于 <code>dp[i-1][w - wt[i-1]] + val[i-1]</code>。</p><p>首先，由于 <code>i</code> 是从 1 开始的，所以 <code>val</code> 和 <code>wt</code> 的索引是 <code>i-1</code> 时表示第 <code>i</code> 个物品的价值和重量。</p><p>而 <code>dp[i-1][w - wt[i-1]]</code> 也很好理解：你如果装了第 <code>i</code> 个物品，就要寻求剩余重量 <code>w - wt[i-1]</code> 限制下的最大价值，加上第 <code>i</code> 个物品的价值 <code>val[i-1]</code>。</p><p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">for i in [1..N]:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for w in [1..W]:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dp[i][w] = max(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i-1][w],</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp[i-1][w - wt[i-1]] + val[i-1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return dp[N][W]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</p><p>我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了 <code>w - wt[i-1]</code> 可能小于 0 导致数组索引越界的问题：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int knapsack(int W, int N, vector&lt;int&gt;&amp; wt, vector&lt;int&gt;&amp; val) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case 已初始化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt;= N; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int w = 1; w &lt;= W; w++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (w - wt[i-1] &lt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这种情况下只能选择不装入背包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i][w] = dp[i - 1][w];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 装入或者不装入背包，择优</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               dp[i - 1][w]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dp[N][W];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>至此，背包问题就解决了，相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导比较自然，基本上你明确了 <code>dp</code> 数组的定义，就可以理所当然地确定状态转移了。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 手把手带你刷二叉树（第一期）</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">动态规划解题套路框架 »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.fd9d2b8e.js"></script>
<script src="/richardgong1987-learn/assets/js/main.279dec3d.js"></script>
</body>
</html>