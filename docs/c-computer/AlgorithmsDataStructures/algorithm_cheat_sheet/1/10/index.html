<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<title data-react-helmet="true">一个函数秒杀 2Sum 3Sum 4Sum 问题 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="一个函数秒杀 2Sum 3Sum 4Sum 问题 | 学习大使"><meta data-react-helmet="true" name="description" content="经常刷 LeetCode 的读者肯定知道鼎鼎有名的 twoSum 问题，我们的旧文 Two Sum 问题的核心思想 对 twoSum 的几个变种做了解析。"><meta data-react-helmet="true" property="og:description" content="经常刷 LeetCode 的读者肯定知道鼎鼎有名的 twoSum 问题，我们的旧文 Two Sum 问题的核心思想 对 twoSum 的几个变种做了解析。"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.b79b5cb9.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.2b37b9e6.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.1709ad9b.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><div class="navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="学习大使" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/richardgong1987-learn/img/logo.svg" alt="学习大使" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">bitmap</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">leetcode</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>一个函数秒杀 2Sum 3Sum 4Sum 问题</h1></header><p>经常刷 LeetCode 的读者肯定知道鼎鼎有名的 <code>twoSum</code> 问题，我们的旧文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484474&amp;idx=1&amp;sn=dfbadbe6e17d695a1907e2adcd9f0d3c&amp;chksm=9bd7fa32aca0732406829a6d1de34b7e3144af239cc25e014f5349d73cea952d5f2b0473345a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">Two Sum 问题的核心思想</a> 对 <code>twoSum</code> 的几个变种做了解析。</p><p>但是除了 <code>twoSum</code> 问题，LeetCode 上面还有 <code>3Sum</code>，<code>4Sum</code> 问题，我估计以后出个 <code>5Sum</code>，<code>6Sum</code> 也不是不可能。</p><p>那么，对于这种问题有没有什么好办法用套路解决呢？本文就由浅入深，层层推进，用一个函数来解决所有 <code>nSum</code> 类型的问题。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="一twosum-问题">一、twoSum 问题<a aria-hidden="true" class="hash-link" href="#一twosum-问题" title="Direct link to heading">​</a></h3><p>力扣上的 twoSum 问题，题目要求返回的是索引，这里我来编一道 twoSum 题目，不要返回索引，返回元素的值：</p><p>如果假设输入一个数组 <code>nums</code> 和一个目标和 <code>target</code>，<strong>请你返回 <code>nums</code> 中能够凑出 <code>target</code> 的两个元素的值</strong>，比如输入 <code>nums = [5,3,1,6], target = 9</code>，那么算法返回两个元素 <code>[3,6]</code>。可以假设只有且仅有一对儿元素可以凑出 <code>target</code>。</p><p>我们可以先对 <code>nums</code> 排序，然后利用前文「<a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484505&amp;idx=1&amp;sn=0e9517f7c4021df0e6146c6b2b0c4aba&amp;chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">双指针技巧汇总</a>」写过的左右双指针技巧，从两端相向而行就行了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先对数组排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 左右指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lo = 0, hi = nums.size() - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sum = nums[lo] + nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据 sum 和 target 的比较，移动左右指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (sum &lt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (sum &gt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (sum == target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return {nums[lo], nums[hi]};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样就可以解决这个问题，不过我们要继续魔改题目，把这个题目变得更泛化，更困难一点：</p><p><strong><code>nums</code> 中可能有多对儿元素之和都等于 <code>target</code>，请你的算法返回所有和为 <code>target</code> 的元素对儿，其中不能出现重复</strong>。</p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; twoSumTarget(vector&lt;int&gt;&amp; nums, int target);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>比如说输入为 <code>nums = [1,3,1,2,2,3], target = 4</code>，那么算法返回的结果就是：<code>[[1,3],[2,2]]</code>。</p><p>对于修改后的问题，关键难点是现在可能有多个和为 <code>target</code> 的数对儿，还不能重复，比如上述例子中 <code>[1,3]</code> 和 <code>[3,1]</code> 就算重复，只能算一次。</p><p>首先，基本思路肯定还是排序加双指针：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; twoSumTarget(vector&lt;int&gt;&amp; nums, int target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先对数组排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lo = 0, hi = nums.size() - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sum = nums[lo] + nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据 sum 和 target 的比较，移动左右指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if      (sum &lt; target) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (sum &gt; target) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_back({lo, hi});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lo++; hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>但是，这样实现会造成重复的结果，比如说 <code>nums = [1,1,1,2,2,3,3], target = 4</code>，得到的结果中 <code>[1,3]</code> 肯定会重复。</p><p>出问题的地方在于 <code>sum == target</code> 条件的 if 分支，当给 <code>res</code> 加入一次结果后，<code>lo</code> 和 <code>hi</code> 不应该改变 1 的同时，还应该跳过所有重复的元素：</p><p><img alt="图片" src="/richardgong1987-learn/assets/images/640-20210923020438062-a323f6cf301f9d1a44b98bba934e8bf9.bin"></p><p>所以，可以对双指针的 while 循环做出如下修改：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sum = nums[lo] + nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 记录索引 lo 和 hi 最初对应的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int left = nums[lo], right = nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (sum &lt; target)      lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (sum &gt; target) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.push_back({left, right});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 跳过所有重复的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; twoSumTarget(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // nums 数组必须有序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lo = 0, hi = nums.size() - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sum = nums[lo] + nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int left = nums[lo], right = nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (sum &lt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (sum &gt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_back({left, right});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，一个通用化的 <code>twoSum</code> 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 <code>3Sum</code> 和 <code>4Sum</code> 的时候会复用这个函数。</p><p>这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 <code>O(N)</code>，而排序的时间复杂度是 <code>O(NlogN)</code>，所以这个函数的时间复杂度是 <code>O(NlogN)</code>。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="二3sum-问题">二、3Sum 问题<a aria-hidden="true" class="hash-link" href="#二3sum-问题" title="Direct link to heading">​</a></h3><p>这是力扣第 15 题「三数之和」：</p><p><img alt="图片" src="/richardgong1987-learn/assets/images/640-20210923020437854-c0fccc1709207c6d9fefe5320950839f.bin"></p><p>题目就是让我们找 <code>nums</code> 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 <code>target</code> 的三元组吧，同上面的 <code>twoSum</code> 一样，也不允许重复的结果：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 求和为 0 的三元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return threeSumTarget(nums, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; threeSumTarget(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 输入数组 nums，返回所有和为 target 的三元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个问题怎么解决呢？<strong>很简单，穷举呗</strong>。现在我们想找和为 <code>target</code> 的三个数字，那么对于第一个数字，可能是什么？<code>nums</code> 中的每一个元素 <code>nums[i]</code> 都有可能！</p><p>那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 <code>target - nums[i]</code> 的两个数字呗，那不就是 <code>twoSum</code> 函数解决的问题么🤔</p><p>可以直接写代码了，需要把 <code>twoSum</code> 函数稍作修改即可复用：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/* 从 nums[start] 开始，计算有序数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * nums 中所有和为 target 的二元组 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; twoSumTarget(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt;&amp; nums, int start, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 左指针改为从 start 开始，其他不变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lo = start, hi = nums.size() - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 计算数组 nums 中所有和为 target 的三元组 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; threeSumTarget(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组得排个序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 穷举 threeSum 的第一个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对 target - nums[i] 计算 twoSum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tuples = twoSumTarget(nums, i + 1, target - nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (vector&lt;int&gt;&amp; tuple : tuples) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tuple.push_back(nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_back(tuple);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 跳过第一个数字重复的情况，否则会出现重复结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1]) i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>需要注意的是，类似 <code>twoSum</code>，<code>3Sum</code> 的结果也可能重复，比如输入是 <code>nums = [1,1,1,2,3], target = 6</code>，结果就会重复。</p><p><strong>关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 <code>twoSum</code> 函数会保证它们不重复</strong>。所以代码中必须用一个 while 循环来保证 <code>3Sum</code> 中第一个元素不重复。</p><p>至此，<code>3Sum</code> 问题就解决了，时间复杂度不难算，排序的复杂度为 <code>O(NlogN)</code>，<code>twoSumTarget</code> 函数中的双指针操作为 <code>O(N)</code>，<code>threeSumTarget</code> 函数在 for 循环中调用 <code>twoSumTarget</code> 所以总的时间复杂度就是 <code>O(NlogN + N^2) = O(N^2)</code>。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="三4sum-问题">三、4Sum 问题<a aria-hidden="true" class="hash-link" href="#三4sum-问题" title="Direct link to heading">​</a></h3><p>这是力扣第 18 题「四数之和」：</p><p><img alt="图片" src="/richardgong1987-learn/assets/images/640-20210923020437934-375397ca3fb9bf08edcae18a99eebca4.bin"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>都到这份上了，<code>4Sum</code> 完全就可以用相同的思路：穷举第一个数字，然后调用 <code>3Sum</code> 函数计算剩下三个数，最后组合出和为 <code>target</code> 的四元组。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组需要排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 穷举 fourSum 的第一个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对 target - nums[i] 计算 threeSum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            triples = threeSumTarget(nums, i + 1, target - nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (vector&lt;int&gt;&amp; triple : triples) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            triple.push_back(nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_back(triple);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // fourSum 的第一个数不能重复</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1]) i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 从 nums[start] 开始，计算有序数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * nums 中所有和为 target 的三元组 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threeSumTarget(vector&lt;int&gt;&amp; nums, int start, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // i 从 start 开始穷举，其他都不变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = start; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，按照相同的套路，<code>4Sum</code> 问题就解决了，时间复杂度的分析和之前类似，for 循环中调用了 <code>threeSumTarget</code> 函数，所以总的时间复杂度就是 <code>O(N^3)</code>。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="四100sum-问题">四、100Sum 问题？<a aria-hidden="true" class="hash-link" href="#四100sum-问题" title="Direct link to heading">​</a></h3><p>在 LeetCode 上，<code>4Sum</code> 就到头了，<strong>但是回想刚才写 <code>3Sum</code> 和 <code>4Sum</code> 的过程，实际上是遵循相同的模式的</strong>。我相信你只要稍微修改一下 <code>4Sum</code> 的函数就可以复用并解决 <code>5Sum</code> 问题，然后解决 <code>6Sum</code> 问题……</p><p>那么，如果我让你求 <code>100Sum</code> 问题，怎么办呢？其实我们可以观察上面这些解法，统一出一个 <code>nSum</code> 函数：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">/* 注意：调用这个函数之前一定要先给 nums 排序 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; nSumTarget(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;int&gt;&amp; nums, int n, int start, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sz = nums.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 至少是 2Sum，且数组大小不应该小于 n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n &lt; 2 || sz &lt; n) return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2Sum 是 base case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 双指针那一套操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int lo = start, hi = sz - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (lo &lt; hi) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int sum = nums[lo] + nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int left = nums[lo], right = nums[hi];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sum &lt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (sum &gt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.push_back({left, right});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // n &gt; 2 时，递归计算 (n-1)Sum 的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = start; i &lt; sz; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            vector&lt;vector&lt;int&gt;&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (vector&lt;int&gt;&amp; arr : sub) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // (n-1)Sum 加上 nums[i] 就是 nSum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arr.push_back(nums[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.push_back(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (i &lt; sz - 1 &amp;&amp; nums[i] == nums[i + 1]) i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>嗯，看起来很长，实际上就是把之前的题目解法合并起来了，<code>n == 2</code> 时是 <code>twoSum</code> 的双指针解法，<code>n &gt; 2</code> 时就是穷举第一个数字，然后递归调用计算 <code>(n-1)Sum</code>，组装答案。</p><p><strong>需要注意的是，调用这个 <code>nSum</code> 函数之前一定要先给 <code>nums</code> 数组排序</strong>，因为 <code>nSum</code> 是一个递归函数，如果在 <code>nSum</code> 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。</p><p>比如说现在我们写 LeetCode 上的 <code>4Sum</code> 问题：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // n 为 4，从 nums[0] 开始计算和为 target 的四元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nSumTarget(nums, 4, 0, target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>再比如 LeetCode 的 <code>3Sum</code> 问题，找 <code>target == 0</code> 的三元组：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sort(nums.begin(), nums.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // n 为 3，从 nums[0] 开始计算和为 0 的三元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nSumTarget(nums, 3, 0, 0);        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>那么，如果让你计算 <code>100Sum</code> 问题，直接调用这个函数就完事儿了。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->学习算法和刷题的框架思维</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">单链表的六大解题套路<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一twosum-问题" class="table-of-contents__link toc-highlight">一、twoSum 问题</a></li><li><a href="#二3sum-问题" class="table-of-contents__link toc-highlight">二、3Sum 问题</a></li><li><a href="#三4sum-问题" class="table-of-contents__link toc-highlight">三、4Sum 问题</a></li><li><a href="#四100sum-问题" class="table-of-contents__link toc-highlight">四、100Sum 问题？</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.2b37b9e6.js"></script>
<script src="/richardgong1987-learn/assets/js/main.1709ad9b.js"></script>
</body>
</html>