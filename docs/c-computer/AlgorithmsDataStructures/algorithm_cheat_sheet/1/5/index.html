<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">把 Dijkstra 算法变成了默写题 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="把 Dijkstra 算法变成了默写题 | 学习大使"><meta data-react-helmet="true" name="description" content="Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。"><meta data-react-helmet="true" property="og:description" content="Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.53345af5.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.0a3156e5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">OfferOrientedAlgorithms-main</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">algorithm_cheat_sheet</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">1</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/1">学习算法和刷题的框架思维</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/10">一个函数秒杀 2Sum 3Sum 4Sum 问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/11">单链表的六大解题套路</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/12">手把手带你刷二叉树（第一期）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/13">经典动态规划：0-1 背包问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/2">动态规划解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/3">回溯算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4">BFS 算法解题套路框架</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5">把 Dijkstra 算法变成了默写题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6">一首二分搜索诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/7">一首把滑动窗口算法算法诗</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/8">一个方法团灭 LeetCode 股票买卖问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/9">一个方法团灭 LeetCode 打家劫舍问题</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/readme">目录</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/intro">算法小抄</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1>把 Dijkstra 算法变成了默写题</h1></header><p>Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。</p><p>这也是为什么我在 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="noopener noreferrer">学习数据结构和算法的框架思维</a> 中这么强调二叉树的原因。</p><p><strong>下面我们由浅入深，从二叉树的层序遍历聊到 Dijkstra 算法，给出 Dijkstra 算法的代码框架，顺手秒杀几道运用 Dijkstra 算法的题目</strong>。</p><header><h1>图的抽象</h1></header><p>前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/tu" target="_blank" rel="noopener noreferrer">图论第一期：遍历基础</a> 说过「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fd9cabcdaabfc00a3529d1097256f11dd20608089.jpg?alt=media" alt="img"></p><p>比如上图这幅图用邻接表和邻接矩阵的存储方式如下：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F7978b9555d0cc81eeeb800cec93a58578f4e71e8.jpeg?alt=media" alt="img"></p><p>前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/tuo-pu-pai-xu" target="_blank" rel="noopener noreferrer">图论第二期：拓扑排序</a> 告诉你，我们用邻接表的场景更多，结合上图，一幅图可以用如下 Java 代码表示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// graph[s] 存储节点 s 指向的节点（出度）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt;[] graph;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>如果你想把一个问题抽象成「图」的问题，那么首先要实现一个 API</strong> <strong><code>adj</code></strong>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入节点 s 返回 s 的相邻节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; adj(int s);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>类似多叉树节点中的 <code>children</code> 字段记录当前节点的所有子节点，<code>adj(s)</code> 就是计算一个节点 <code>s</code> 的相邻节点。</p><p>比如上面说的用邻接表表示「图」的方式，<code>adj</code> 函数就可以这样表示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt;[] graph;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入节点 s，返回 s 的相邻节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; adj(int s) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return graph[s];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当然，对于「加权图」，我们需要知道两个节点之间的边权重是多少，所以还可以抽象出一个 <code>weight</code> 方法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 返回节点 from 到节点 to 之间的边的权重</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int weight(int from, int to);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个 <code>weight</code> 方法可以根据实际情况而定，因为不同的算法题，题目给的「权重」含义可能不一样，我们存储权重的方式也不一样。</p><p>有了上述基础知识，就可以搞定 Dijkstra 算法了，下面我给你从二叉树的层序遍历开始推演出 Dijkstra 算法的实现。</p><header><h1>二叉树层级遍历和 BFS 算法</h1></header><p>我们之前说过二叉树的层级遍历框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void levelTraverse(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    q.offer(root);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int depth = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从上到下遍历二叉树的每一层</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!q.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sz = q.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从左到右遍历每一层的每个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; sz; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            TreeNode cur = q.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;节点 %s 在第 %s 层&quot;, cur, depth);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将下一层节点放入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cur.left != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                q.offer(cur.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cur.right != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                q.offer(cur.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        depth++;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们先来思考一个问题，注意二叉树的层级遍历 <code>while</code> 循环里面还套了个 <code>for</code> 循环，为什么要这样？</p><p><code>while</code> 循环和 <code>for</code> 循环的配合正是这个遍历框架设计的巧妙之处：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F1f45adf975a50bef0433f806a0c16f693ca3f0ed.jpeg?alt=media" alt="img"></p><p><strong><code>while</code></strong> <strong>循环控制一层一层往下走，**</strong><code>for</code>** <strong>循环利用</strong> <strong><code>sz</code></strong> <strong>变量控制从左到右遍历每一层二叉树节点</strong>。</p><p>注意我们代码框架中的 <code>depth</code> 变量，其实就记录了当前遍历到的层数。换句话说，每当我们遍历到一个节点 <code>cur</code>，都知道这个节点属于第几层。</p><p>算法题经常会问二叉树的最大深度呀，最小深度呀，层序遍历结果呀，等等问题，所以记录下来这个深度 <code>depth</code> 是有必要的。</p><p>基于二叉树的遍历框架，我们又可以扩展出多叉树的层序遍历框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一棵多叉树的根节点，层序遍历这棵多叉树</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void levelTraverse(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    q.offer(root);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int depth = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从上到下遍历多叉树的每一层</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!q.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sz = q.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从左到右遍历每一层的每个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; sz; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            TreeNode cur = q.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;节点 %s 在第 %s 层&quot;, cur, depth);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将下一层节点放入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (TreeNode child : cur.children) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                q.offer(child);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        depth++;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>基于多叉树的遍历框架，我们又可以扩展出 BFS（广度优先搜索）的算法框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入起点，进行 BFS 搜索</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int BFS(Node start) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Node&gt; q; // 核心数据结构</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;Node&gt; visited; // 避免走回头路</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    q.offer(start); // 将起点加入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited.add(start);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int step = 0; // 记录搜索的步数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (q not empty) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sz = q.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* 将当前队列中的所有节点向四周扩散一步 */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; sz; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node cur = q.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;从 %s 到 %s 的最短距离是 %s&quot;, start, cur, step);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* 将 cur 的相邻节点加入队列 */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Node x : cur.adj()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (x not in visited) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    q.offer(x);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    visited.add(x);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        step++;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>如果对 BFS 算法不熟悉，可以看前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye-1/bfs-kuang-jia" target="_blank" rel="noopener noreferrer">BFS 算法框架</a>，这里只是为了让你做个对比，所谓 BFS 算法，就是把算法问题抽象成一幅「无权图」，然后继续玩二叉树层级遍历那一套罢了。</p><p><strong>注意，我们的 BFS 算法框架也是</strong> <strong><code>while</code></strong> <strong>循环嵌套</strong> <strong><code>for</code></strong> <strong>循环的形式，也用了一个</strong> <strong><code>step</code></strong> <strong>变量记录</strong> <strong><code>for</code></strong> <strong>循环执行的次数，无非就是多用了一个</strong> <strong><code>visited</code></strong> <strong>集合记录走过的节点，防止走回头路罢了</strong>。</p><p>为什么这样呢？</p><p>所谓「无权图」，与其说每条「边」没有权重，不如说每条「边」的权重都是 1，从起点 <code>start</code> 到任意一个节点之间的路径权重就是它们之间「边」的条数，那可不就是 <code>step</code> 变量记录的值么？</p><p>再加上 BFS 算法利用 <code>for</code> 循环一层一层向外扩散的逻辑和 <code>visited</code> 集合防止走回头路的逻辑，当你每次从队列中拿出节点 <code>cur</code> 的时候，从 <code>start</code> 到 <code>cur</code> 的最短权重就是 <code>step</code> 记录的步数。</p><p>但是，到了「加权图」的场景，事情就没有这么简单了，因为你不能默认每条边的「权重」都是 1 了，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F5e2ee661d2cfa076dddfd9e64225f991614d6e32.jpeg?alt=media" alt="img"></p><p>如果沿用 BFS 算法中的 <code>step</code> 变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。</p><p>其实 Dijkstra 和 BFS 算法差不多，不过在讲解 Dijkstra 算法框架之前，我们首先需要对之前的框架进行如下改造：</p><p><strong>想办法去掉</strong> <strong><code>while</code></strong> <strong>循环里面的</strong> <strong><code>for</code></strong> <strong>循环</strong>。</p><p>为什么？有了刚才的铺垫，这个不难理解，刚才说 <code>for</code> 循环是干什么用的来着？</p><p>是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 <code>depth</code>，或者这个步数 <code>step</code>，在之前的场景中有用。</p><p>但现在我们想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 <code>for</code> 循环可以被去掉。</p><p>怎么去掉？就拿二叉树的层级遍历来说，其实你可以直接去掉 <code>for</code> 循环相关的代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void levelTraverse(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    q.offer(root);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历二叉树的每一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!q.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TreeNode cur = q.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;我不知道节点 %s 在第几层&quot;, cur);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将子节点放入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur.left != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.offer(cur.left);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur.right != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.offer(cur.right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>但问题是，没有 <code>for</code> 循环，你也没办法维护 <code>depth</code> 变量了。</p><p>如果你想同时维护 <code>depth</code> 变量，让每个节点 <code>cur</code> 知道自己在第几层，可以想其他办法，比如新建一个 <code>State</code> 类，记录每个节点所在的层数：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class State {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 记录 node 节点的深度</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int depth;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TreeNode node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    State(TreeNode node, int depth) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.depth = depth;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.node = node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void levelTraverse(TreeNode root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == null) return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;State&gt; q = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    q.offer(new State(root, 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历二叉树的每一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!q.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State cur = q.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TreeNode cur_node = cur.node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int cur_depth = cur.depth;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;节点 %s 在第 %s 层&quot;, cur_node, cur_depth);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将子节点放入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur_node.left != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.offer(new State(cur_node.left, cur_depth + 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur_node.right != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            q.offer(new State(cur_node.right, cur_depth + 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样，我们就可以不使用 <code>for</code> 循环也确切地知道每个二叉树节点的深度了。</p><p><strong>如果你能够理解上面这段代码，我们就可以来看 Dijkstra 算法的代码框架了</strong>。</p><header><h1>Dijkstra 算法框架</h1></header><p><strong>首先，我们先看一下 Dijkstra 算法的签名</strong>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] dijkstra(int start, List&lt;Integer&gt;[] graph);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>输入是一幅图 <code>graph</code> 和一个起点 <code>start</code>，返回是一个记录最短路径权重的数组。</p><p>比方说，输入起点 <code>start = 3</code>，函数返回一个 <code>int[]</code> 数组，假设赋值给 <code>distTo</code> 变量，那么从起点 <code>3</code> 到节点 <code>6</code> 的最短路径权重的值就是 <code>distTo[6]</code>。</p><p>是的，标准的 Dijkstra 算法会把从起点 <code>start</code> 到所有其他节点的最短路径都算出来。</p><p>当然，如果你的需求只是计算从起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。</p><p><strong>其次，我们也需要一个</strong> <strong><code>State</code></strong> <strong>类来辅助算法的运行</strong>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class State {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 图节点的 id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从 start 节点到当前节点的距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    State(int id, int distFromStart) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id = id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.distFromStart = distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>类似刚才二叉树的层序遍历，我们也需要用 <code>State</code> 类记录一些额外信息，也就是使用 <code>distFromStart</code> 变量记录从起点 <code>start</code> 到当前这个节点的距离。</p><p>刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 <code>visited</code> 数组防止走回头路，每个节点只会经过一次。</p><p>加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 <code>distFromStart</code> 可能都不一样，比如下图：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F2495adfb0505d08a080f5fc1ddf106f1648299b8.jpeg?alt=media" alt="img"></p><p>我会经过节点 <code>5</code> 三次，每次的 <code>distFromStart</code> 值都不一样，那我取 <code>distFromStart</code> 最小的那次，不就是从起点 <code>start</code> 到节点 <code>5</code> 的最短路径权重了么？</p><p>好了，明白上面的几点，我们可以来看看 Dijkstra 算法的代码模板。</p><p><strong>其实，Dijkstra 可以理解成一个带 dp table（或者说备忘录）的 BFS 算法，伪码如下</strong>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 返回节点 from 到节点 to 之间的边的权重</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int weight(int from, int to);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入节点 s 返回 s 的相邻节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; adj(int s);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] dijkstra(int start, List&lt;Integer&gt;[] graph) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 图中节点的个数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int V = graph.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 记录最短路径的权重，你可以理解为 dp table</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] distTo = new int[V];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 求最小值，所以 dp table 初始化为正无穷</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(distTo, Integer.MAX_VALUE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case，start 到 start 的最短距离就是 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    distTo[start] = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 优先级队列，distFromStart 较小的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a.distFromStart - b.distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从起点 start 开始进行 BFS</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    pq.offer(new State(start, 0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State curState = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curNodeID = curState.id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curDistFromStart = curState.distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curDistFromStart &gt; distTo[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 已经有一条更短的路径到达 curNode 节点了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将 curNode 的相邻节点装入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int nextNodeID : adj(curNodeID)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (distTo[nextNodeID] &gt; distToNextNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 更新 dp table</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                distTo[nextNodeID] = distToNextNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将这个节点以及距离放入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.offer(new State(nextNodeID, distToNextNode));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return distTo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>对比普通的 BFS 算法，你可能会有以下疑问</strong>：</p><p><strong>1、没有</strong> <strong><code>visited</code></strong> <strong>集合记录已访问的节点，所以一个节点会被访问多次，会被多次加入队列，那会不会导致队列永远不为空，造成死循环</strong>？</p><p><strong>2、为什么用优先级队列</strong> <strong><code>PriorityQueue</code></strong> <strong>而不是</strong> <strong><code>LinkedList</code></strong> <strong>实现的普通队列？为什么要按照</strong> <strong><code>distFromStart</code></strong> <strong>的值来排序</strong>？</p><p><strong>3、如果我只想计算起点</strong> <strong><code>start</code></strong> <strong>到某一个终点</strong> <strong><code>end</code></strong> <strong>的最短路径，是否可以修改算法，提升一些效率</strong>？</p><p>我们先回答第一个问题，为什么这个算法不用 <code>visited</code> 集合也不会死循环。</p><p>对于这类问题，我教你一个思考方法：</p><p>循环结束的条件是队列为空，那么你就要注意看什么时候往队列里放元素（调用 <code>offer</code>）方法，再注意看什么时候从队列往外拿元素（调用 <code>poll</code> 方法）。</p><p><code>while</code> 循环每执行一次，都会往外拿一个元素，但想往队列里放元素，可就有很多限制了，必须满足下面这个条件：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (distTo[nextNodeID] &gt; distToNextNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新 dp table</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    distTo[nextNodeID] = distToNextNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    pq.offer(new State(nextNodeID, distToNextNode));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这也是为什么我说 <code>distTo</code> 数组可以理解成我们熟悉的 dp table，因为这个算法逻辑就是在不断的最小化 <code>distTo</code> 数组中的元素：</p><p>如果你能让到达 <code>nextNodeID</code> 的距离更短，那就更新 <code>distTo[nextNodeID]</code> 的值，让你入队，否则的话对不起，不让入队。</p><p><strong>因为两个节点之间的最短距离（路径权重）肯定是一个确定的值，不可能无限减小下去，所以队列一定会空，队列空了之后，**</strong><code>distTo</code>** <strong>数组中记录的就是从</strong> <strong><code>start</code></strong> <strong>到其他节点的最短距离</strong>。</p><p>接下来解答第二个问题，为什么要用 <code>PriorityQueue</code> 而不是 <code>LinkedList</code> 实现的普通队列？</p><p>如果你非要用普通队列，其实也没问题的，你可以直接把 <code>PriorityQueue</code> 改成 <code>LinkedList</code>，也能得到正确答案，但是效率会低很多。</p><p><strong>Dijkstra 算法使用优先级队列，主要是为了效率上的优化，类似一种贪心算法的思路</strong>。</p><p>为什么说是一种贪心思路呢，比如说下面这种情况，你想计算从起点 <code>start</code> 到终点 <code>end</code> 的最短路径权重：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F2f2f2b1b5f385c262ba0163a4217b15a5f0ac5e2.jpeg?alt=media" alt="img"></p><p>你下一步想遍历那个节点？就当前的情况来看，你觉得哪条路径更有「潜力」成为最短路径中的一部分？</p><p>从目前的情况来看，显然橙色路径的可能性更大嘛，所以我们希望节点 <code>2</code> 排在队列靠前的位置，优先被拿出来向后遍历。</p><p>所以我们使用 <code>PriorityQueue</code> 作为队列，让 <code>distFromStart</code> 的值较小的节点排在前面，这就类似我们之前讲 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-3/tiao-yue-you-xi" target="_blank" rel="noopener noreferrer">贪心算法</a> 说到的贪心思路，可以很大程度上优化算法的效率。</p><p>大家应该听过 Bellman-Ford 算法，这个算法是一种更通用的最短路径算法，因为它可以处理带有负权重边的图，Bellman-Ford 算法逻辑和 Dijkstra 算法非常类似，用到的就是普通队列，本文就提一句，后面有空再具体写。</p><p>接下来说第三个问题，如果只关心起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，是否可以修改代码提升算法效率。</p><p>肯定可以的，因为我们标准 Dijkstra 算法会算出 <code>start</code> 到所有其他节点的最短路径，你只想计算到 <code>end</code> 的最短路径，相当于减少计算量，当然可以提升效率。</p><p>需要在代码中做的修改也非常少，只要改改函数签名，再加个 if 判断就行了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入起点 start 和终点 end，计算起点到终点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int dijkstra(int start, int end, List&lt;Integer&gt;[] graph) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State curState = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curNodeID = curState.id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curDistFromStart = curState.distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在这里加一个判断就行了，其他代码不用改</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curNodeID == end) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return curDistFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curDistFromStart &gt; distTo[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果运行到这里，说明从 start 无法走到 end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Integer.MAX_VALUE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>因为优先级队列自动排序的性质，<strong>每次</strong>从队列里面拿出来的都是 <code>distFromStart</code> 值最小的，所以当你从队头拿出一个节点，如果发现这个节点就是终点 <code>end</code>，那么 <code>distFromStart</code> 对应的值就是从 <code>start</code> 到 <code>end</code> 的最短距离。</p><p>这个算法较之前的实现提前 return 了，所以效率有一定的提高。</p><header><h1>时间复杂度分析</h1></header><p>Dijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 <code>O(ElogV)</code>，其中 <code>E</code> 代表图中边的条数，<code>V</code> 代表图中节点的个数。</p><p>因为理想情况下优先级队列中最多装 <code>V</code> 个节点，对优先级队列的操作次数和 <code>E</code> 成正比，所以整体的时间复杂度就是 <code>O(ElogV)</code>。</p><p>不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。</p><p>比如本文实现的 Dijkstra 算法，使用了 Java 的 <code>PriorityQueue</code> 这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 <code>E</code> 个节点存在队列中。</p><p>所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 <code>O(ElogV)</code>，而是 <code>O(ElogE)</code>，可能会略大一些，因为图中边的条数一般是大于节点的个数的。</p><p>不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。</p><header><h1>秒杀三道题目</h1></header><p>以上说了 Dijkstra 算法的框架，下面我们套用这个框架做几道题，实践出真知。</p><p>第一题是力扣第 743 题「网络延迟时间」，题目如下：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fe55b32ccfa7310b164dd73d9836b0e1805056b15.jpg?alt=media" alt="img"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// times 记录边和权重，n 为节点个数（从 1 开始），k 为起点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 计算从 k 发出的信号至少需要多久传遍整幅图</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int networkDelayTime(int[][] times, int n, int k)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 <code>k</code> 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 <code>k</code> 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。</p><p>在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。</p><p>根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public int networkDelayTime(int[][] times, int n, int k) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 节点编号是从 1 开始的，所以要一个大小为 n + 1 的邻接表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;int[]&gt;[] graph = new LinkedList[n + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt;= n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph[i] = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构造图</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] edge : times) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int from = edge[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int to = edge[1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int weight = edge[2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // from -&gt; List&lt;(to, weight)&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 邻接表存储图结构，同时存储权重信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph[from].add(new int[]{to, weight});</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] distTo = dijkstra(k, graph);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 找到最长的那一条最短路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; distTo.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (distTo[i] == Integer.MAX_VALUE) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 有节点不可达，返回 -1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = Math.max(res, distTo[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一个起点 start，计算从 start 到其他节点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] dijkstra(int start, List&lt;int[]&gt;[] graph) {}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>上述代码首先利用题目输入的数据转化成邻接表表示一幅图，接下来我们可以直接套用 Dijkstra 算法的框架：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class State {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 图节点的 id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从 start 节点到当前节点的距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    State(int id, int distFromStart) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id = id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.distFromStart = distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一个起点 start，计算从 start 到其他节点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] dijkstra(int start, List&lt;int[]&gt;[] graph) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] distTo = new int[graph.length];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(distTo, Integer.MAX_VALUE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case，start 到 start 的最短距离就是 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    distTo[start] = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 优先级队列，distFromStart 较小的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a.distFromStart - b.distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从起点 start 开始进行 BFS</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    pq.offer(new State(start, 0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State curState = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curNodeID = curState.id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curDistFromStart = curState.distFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curDistFromStart &gt; distTo[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将 curNode 的相邻节点装入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] neighbor : graph[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextNodeID = neighbor[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int distToNextNode = distTo[curNodeID] + neighbor[1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新 dp table</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (distTo[nextNodeID] &gt; distToNextNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                distTo[nextNodeID] = distToNextNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.offer(new State(nextNodeID, distToNextNode));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return distTo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>你对比之前说的代码框架，只要稍稍修改，就可以把这道题目解决了。</p><p>感觉这道题完全没有难度，下面我们再看一道题目，力扣第 1631 题「最小体力消耗路径」：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2F8053191938f671c7a93c584ab2b1e91204971322.jpg?alt=media" alt="img"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一个二维矩阵，计算从左上角到右下角的最小体力消耗</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int minimumEffortPath(int[][] heights);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们常见的二维矩阵题目，如果让你从左上角走到右下角，比较简单的题一般都会限制你只能向右或向下走，但这道题可没有限制哦，你可以上下左右随便走，只要路径的「体力消耗」最小就行。</p><p>如果你把二维数组中每个 <code>(x, y)</code> 坐标看做一个节点，它的上下左右坐标就是相邻节点，它对应的值和相邻坐标对应的值之差的绝对值就是题目说的「体力消耗」，你就可以理解为边的权重。</p><p>这样一想，是不是就在让你以左上角坐标为起点，以右下角坐标为终点，计算起点到终点的最短路径？Dijkstra 算法是不是可以做到？</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入起点 start 和终点 end，计算起点到终点的最短距离</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int dijkstra(int start, int end, List&lt;Integer&gt;[] graph)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>只不过，这道题中评判一条路径是长还是短的标准不再是路径经过的权重总和，而是路径经过的权重最大值</strong>。</p><p>明白这一点，再想一下使用 Dijkstra 算法的前提，加权有向图，没有负权重边，求最短路径，OK，可以使用，咱们来套框架。</p><p>二维矩阵抽象成图，我们先实现一下图的 <code>adj</code> 方法，之后的主要逻辑会清晰一些：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 方向数组，上下左右的坐标偏移量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][] dirs = new int[][]{{0,1}, {1,0}, {0,-1}, {-1,0}};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 返回坐标 (x, y) 的上下左右相邻坐标</span></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;int[]&gt; adj(int[][] matrix, int x, int y) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int m = matrix.length, n = matrix[0].length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存储相邻节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;int[]&gt; neighbors = new ArrayList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] dir : dirs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int nx = x + dir[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ny = y + dir[1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nx &gt;= m || nx &lt; 0 || ny &gt;= n || ny &lt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 索引越界</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        neighbors.add(new int[]{nx, ny});</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return neighbors;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>类似的，我们现在认为一个二维坐标 <code>(x, y)</code> 是图中的一个节点，所以这个 <code>State</code> 类也需要修改一下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class State {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 矩阵中的一个位置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int x, y;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从起点 (0, 0) 到当前位置的最小体力消耗（距离）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int effortFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    State(int x, int y, int effortFromStart) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.x = x;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.y = y;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.effortFromStart = effortFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>接下来，就可以套用 Dijkstra 算法的代码模板了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// Dijkstra 算法，计算 (0, 0) 到 (m - 1, n - 1) 的最小体力消耗</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int minimumEffortPath(int[][] heights) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int m = heights.length, n = heights[0].length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义：从 (0, 0) 到 (i, j) 的最小体力消耗是 effortTo[i][j]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] effortTo = new int[m][n];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // dp table 初始化为正无穷</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; m; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.fill(effortTo[i], Integer.MAX_VALUE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case，起点到起点的最小消耗就是 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    effortTo[0][0] = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 优先级队列，effortFromStart 较小的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a.effortFromStart - b.effortFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从起点 (0, 0) 开始进行 BFS</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    pq.offer(new State(0, 0, 0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State curState = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curX = curState.x;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curY = curState.y;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curEffortFromStart = curState.effortFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 到达终点提前结束</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curX == m - 1 &amp;&amp; curY == n - 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return curEffortFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curEffortFromStart &gt; effortTo[curX][curY]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将 (curX, curY) 的相邻坐标装入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] neighbor : adj(heights, curX, curY)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextX = neighbor[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextY = neighbor[1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 计算从 (curX, curY) 达到 (nextX, nextY) 的消耗</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int effortToNextNode = Math.max(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                effortTo[curX][curY], </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Math.abs(heights[curX][curY] - heights[nextX][nextY])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新 dp table</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (effortTo[nextX][nextY] &gt; effortToNextNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                effortTo[nextX][nextY] = effortToNextNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.offer(new State(nextX, nextY, effortToNextNode));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 正常情况不会达到这个 return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>你看，稍微改一改代码模板，这道题就解决了。</p><p>最后看一道题吧，力扣第 1514 题「概率最大的路径」，看下题目：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MgaO_np8dKO0rzhRKXx%2Fsync%2Fa47f033206f92d986670834867a69b428ff6e461.jpg?alt=media" alt="img"></p><p>函数签名如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 输入一幅无向图，边上的权重代表概率，返回从 start 到达 end 最大的概率</span></span><span class="token-line" style="color:#393A34"><span class="token plain">double maxProbability(int n, int[][] edges, double[] succProb, int start, int end)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我说这题一看就是 Dijkstra 算法，但聪明的你肯定会反驳我：</p><p><strong>1、这题给的是无向图，也可以用 Dijkstra 算法吗</strong>？</p><p><strong>2、更重要的是，Dijkstra 算法计算的是最短路径，计算的是最小值，这题让你计算最大概率是一个最大值，怎么可能用 Dijkstra 算法呢</strong>？</p><p>问得好！</p><p>首先关于有向图和无向图，前文 <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/tu" target="_blank" rel="noopener noreferrer">图算法基础</a> 说过，无向图本质上可以认为是「双向图」，从而转化成有向图。</p><p>重点说说最大值和最小值这个问题，其实 Dijkstra 和很多最优化算法一样，计算的是「最优值」，这个最优值可能是最大值，也可能是最小值。</p><p>标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？</p><p><strong>因为 Dijkstra 计算最短路径的正确性依赖一个前提：路径中每增加一条边，路径的总权重就会增加</strong>。</p><p>这个前提的数学证明大家有兴趣可以自己搜索一下，我这里只说结论，其实你把这个结论反过来也是 OK 的：</p><p>如果你想计算最长路径，路径中每增加一条边，路径的总权重就会减少，要是能够满足这个条件，也可以用 Dijkstra 算法。</p><p>你看这道题是不是符合这个条件？边和边之间是乘法关系，每条边的概率都是小于 1 的，所以肯定会越乘越小。</p><p>只不过，这道题的解法要把优先级队列的排序顺序反过来，一些 if 大小判断也要反过来，我们直接看解法代码吧：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;double[]&gt;[] graph = new LinkedList[n];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; n; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph[i] = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构造邻接表结构表示图</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; edges.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int from = edges[i][0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int to = edges[i][1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double weight = succProb[i];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 无向图就是双向图；先把 int 统一转成 double，待会再转回来</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph[from].add(new double[]{(double)to, weight});</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph[to].add(new double[]{(double)from, weight});</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dijkstra(start, end, graph);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class State {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 图节点的 id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从 start 节点到达当前节点的概率</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    double probFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    State(int id, double probFromStart) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id = id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.probFromStart = probFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">double dijkstra(int start, int end, List&lt;double[]&gt;[] graph) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义：probTo[i] 的值就是节点 start 到达节点 i 的最大概率</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    double[] probTo = new double[graph.length];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // dp table 初始化为一个取不到的最小值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(probTo, -1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // base case，start 到 start 的概率就是 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    probTo[start] = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 优先级队列，probFromStart 较大的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Double.compare(b.probFromStart, a.probFromStart);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从起点 start 开始进行 BFS</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    pq.offer(new State(start, 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!pq.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        State curState = pq.poll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int curNodeID = curState.id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double curProbFromStart = curState.probFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遇到终点提前返回</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curNodeID == end) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return curProbFromStart;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (curProbFromStart &lt; probTo[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 已经有一条概率更大的路径到达 curNode 节点了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将 curNode 的相邻节点装入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (double[] neighbor : graph[curNodeID]) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextNodeID = (int)neighbor[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 看看从 curNode 达到 nextNode 的概率是否会更大</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            double probToNextNode = probTo[curNodeID] * neighbor[1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (probTo[nextNodeID] &lt; probToNextNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                probTo[nextNodeID] = probToNextNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq.offer(new State(nextNodeID, probToNextNode));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果到达这里，说明从 start 开始无法到达 end，返回 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0.0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>好了，到这里本文就结束了，总共 6000 多字，这三道例题都是比较困难的，如果你能够看到这里，真得给你鼓掌。</p><p>还是那句话，做题在质不在量，希望大家能够透彻理解最基本的数据结构，以不变应万变。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/5.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/4"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« BFS 算法解题套路框架</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/6"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">一首二分搜索诗 »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.53345af5.js"></script>
<script src="/richardgong1987-learn/assets/js/main.0a3156e5.js"></script>
</body>
</html>