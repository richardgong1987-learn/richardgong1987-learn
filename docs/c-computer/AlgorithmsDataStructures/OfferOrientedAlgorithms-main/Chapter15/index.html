<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">第十五章：图 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="第十五章：图 | 学习大使"><meta data-react-helmet="true" name="description" content="面试题105：最大的岛屿"><meta data-react-helmet="true" property="og:description" content="面试题105：最大的岛屿"><link data-react-helmet="true" rel="icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.c16c760c.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.06e72fca.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.c82129bb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><div class="navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="学习大使" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/richardgong1987-learn/img/logo.svg" alt="学习大使" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">AlgorithmsDataStructures</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/BinaryTree/">BinaryTree</a><button aria-label="Toggle the collapsible sidebar category &#x27;BinaryTree&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/algorithm_cheat_sheet/1/">algorithm_cheat_sheet</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/bitmap/">bitmap</a><button aria-label="Toggle the collapsible sidebar category &#x27;bitmap&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/labuladong算法小抄代码/SUMMARY">labuladong算法小抄代码</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/">OfferOrientedAlgorithms-main</a><button aria-label="Toggle the collapsible sidebar category &#x27;OfferOrientedAlgorithms-main&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter01">第一章：整数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter02">第二章：数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter03">第三章：字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter04">第四章：链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter05">第五章：哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter06">第六章：栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter07">第七章：队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter08">第八章：树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter09">第九章：堆</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10">第十章：前缀树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter11">第十一章：二分查找</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter12">第十二章：排序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter13">第十三章：回溯法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter14">第十四章：动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15">第十五章：图</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" tabindex="0" href="/richardgong1987-learn/docs/c-computer/leetcode/BST/leetcode96">leetcode</a></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>第十五章：图</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题105最大的岛屿">面试题105：最大的岛屿<a class="hash-link" href="#面试题105最大的岛屿" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目">题目<a class="hash-link" href="#题目" title="Direct link to heading">​</a></h3><p>海洋岛屿地图可以用由0、1组成的二维数组表示，水平或者竖直方向相连的一组1表示一个岛屿。请计算最大的岛屿的面积（即岛屿中1的数目）。例如，在图15.5中有4个岛屿，其中最大的岛屿的面积为5。</p><p><img alt="图15.5" src="/richardgong1987-learn/assets/images/1505-b9fd5cdbfbdd8b390c343e11ece25988.png" width="172" height="148"></p><p>图15.5：用0、1矩阵表示的海洋岛屿地图。地图中有4个岛屿，最大的岛屿的面积为5。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码">参考代码<a class="hash-link" href="#参考代码" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法一">解法一<a class="hash-link" href="#解法一" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int maxAreaOfIsland(int[][] grid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rows = grid.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cols = grid[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean[][] visited = new boolean[rows][cols];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxArea = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; rows; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; cols; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int area = getArea(grid, visited, i, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                maxArea = Math.max(maxArea, area);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return maxArea;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int getArea(int[][]grid, boolean[][] visited, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.add(new int[]{i, j});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited[i][j] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int area = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] pos = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        area++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] dir : dirs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int r = pos[0] + dir[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = pos[1] + dir[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (r &gt;= 0 &amp;&amp; r &lt; grid.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; grid[0].length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; grid[r][c] == 1 &amp;&amp; !visited[r][c]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(new int[]{r, c});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                visited[r][c] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return area;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法二">解法二<a class="hash-link" href="#解法二" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int maxAreaOfIsland(int[][] grid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rows = grid.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cols = grid[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean[][] visited = new boolean[rows][cols];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxArea = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; rows; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; cols; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int area = getArea(grid, visited, i, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                maxArea = Math.max(maxArea, area);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return maxArea;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int getArea(int[][]grid, boolean[][] visited, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Stack&lt;int[]&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stack.push(new int[]{i, j});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited[i][j] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int area = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!stack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] pos = stack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        area++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] dir : dirs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int r = pos[0] + dir[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = pos[1] + dir[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (r &gt;= 0 &amp;&amp; r &lt; grid.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; grid[0].length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; grid[r][c] == 1 &amp;&amp; !visited[r][c]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(new int[]{r, c});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                visited[r][c] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return area;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法三">解法三<a class="hash-link" href="#解法三" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int maxAreaOfIsland(int[][] grid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rows = grid.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cols = grid[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean[][] visited = new boolean[rows][cols];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxArea = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; rows; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; cols; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int area = getArea(grid, visited, i, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                maxArea = Math.max(maxArea, area);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return maxArea;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int getArea(int[][]grid, boolean[][] visited, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int area = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visited[i][j] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] dir : dirs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int r = i + dir[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = j + dir[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (r &gt;= 0 &amp;&amp; r &lt; grid.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; grid[0].length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; grid[r][c] == 1 &amp;&amp; !visited[r][c]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                area += getArea(grid, visited, r, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return area;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题106二分图">面试题106：二分图<a class="hash-link" href="#面试题106二分图" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-1">题目<a class="hash-link" href="#题目-1" title="Direct link to heading">​</a></h3><p>如果能将一个图的结点分成A、B两部分，使得任意一条边的一个结点属于A另一个结点属于B，那么该图就是一个二分图。输入一个由数组graph表示的图，graph<!-- -->[i]<!-- -->里包含所有和结点i相邻的结点，请判断该图是否为二分图。例如，如果输入graph为[<!-- -->[1, 3]<!-- -->, <!-- -->[0, 2]<!-- -->, <!-- -->[1, 3]<!-- -->, <!-- -->[0, 2]<!-- -->]，那么我们可以将结点分为{0, 2}、{1, 3}两部分，因此该图是一个二分图，如图15.7（a）所示。如果输入graph为[<!-- -->[1,2,3]<!-- -->,<!-- -->[0,2]<!-- -->,<!-- -->[0,1,3]<!-- -->,<!-- -->[0,2]<!-- -->]，则不是一个二分图，如图15.7（b）所示。</p><p> <img alt="图15.7" src="/richardgong1987-learn/assets/images/1507-3fbeb3cb59b410edb962281695e2a629.png" width="380" height="205"></p><p>图15.7：二分图与非二分图。（a）二分图。（b）不是二分图。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-1">参考代码<a class="hash-link" href="#参考代码-1" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法一-1">解法一<a class="hash-link" href="#解法一-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean isBipartite(int[][] graph) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int size = graph.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] colors = new int[size];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(colors, -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; size; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (colors[i] == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!setColor(graph, colors, i, 0)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean setColor(int[][] graph, int[] colors, int i, int color) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    colors[i] = color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int v = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int neighbor : graph[v]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (colors[neighbor] &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (colors[neighbor] == colors[v]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                colors[neighbor] = 1 - colors[v];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法二-1">解法二<a class="hash-link" href="#解法二-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean isBipartite(int[][] graph) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int size = graph.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] colors = new int[size];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.fill(colors, -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; size; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (colors[i] == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!setColor(graph, colors, i, 0)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean setColor(int[][] graph, int[] colors, int i, int color) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (colors[i] &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return colors[i] == color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    colors[i] = color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int neighbor : graph[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!setColor(graph, colors, neighbor, 1 - color)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题107矩阵中的距离">面试题107：矩阵中的距离<a class="hash-link" href="#面试题107矩阵中的距离" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-2">题目<a class="hash-link" href="#题目-2" title="Direct link to heading">​</a></h3><p>输入一个有0、1组成的矩阵M，请输出一个大小相同的矩阵D，矩阵D中的每个格子是M中对应格子离最近的0的距离。水平或者竖直方向相邻两个格子的距离为1。假设矩阵M中至少要有一个0。例如，图15.8（a）是一个只包含0、1的矩阵M，它每个格子离最近的0的距离如15.8（b）的矩阵D所示。矩阵M<!-- -->[0][0]<!-- -->等于0，因此它离最近的0的距离是0，所以D<!-- -->[0][0]<!-- -->等于0。M<!-- -->[2][1]<!-- -->等于1，离它最近的0的坐标是(0, 1)、(1, 0)、(1, 2)，它们离坐标(2, 1)的距离都是2，所以D<!-- -->[2][1]<!-- -->等于2。</p><p><img alt="图15.8" src="data:image/png;base64,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" width="278" height="165"></p><p>图15.8：矩阵中离0最近的距离。（a）一个只包含0、1的矩阵。（b）每个格子为（a）中矩阵相应位置离最近的0的距离。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-2">参考代码<a class="hash-link" href="#参考代码-2" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int[][] updateMatrix(int[][] matrix) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rows = matrix.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cols = matrix[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] dists = new int[rows][cols];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; rows; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; cols; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (matrix[i][j] == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(new int[]{i, j});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dists[i][j] = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dists[i][j] = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] pos = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int dist = dists[pos[0]][pos[1]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int[] dir : dirs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int r = pos[0] + dir[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int c = pos[1] + dir[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &lt; cols) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dists[r][c] &gt; dist + 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dists[r][c] = dist + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    queue.add(new int[]{r, c});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dists;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题108单词演变">面试题108：单词演变<a class="hash-link" href="#面试题108单词演变" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-3">题目<a class="hash-link" href="#题目-3" title="Direct link to heading">​</a></h3><p>输入两个长度相同但内容不同的单词（beginWord和endWord）和一个单词列表，请问从beginWord到endWord的演变序列的最短长度，要求每一步只能改变单词中的一个字母，并且演变过程中每一步得到的单词都必须在给定的单词列表中。如果不能从beginWord演变到endWord，则返回0。假设所有单词只包含英文的小写字母。例如，如果beginWord为&quot;hit&quot;，endWord为&quot;cog&quot;，单词列表为<!-- -->[&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;, &quot;lot&quot;, &quot;log&quot;, &quot;cog&quot;]<!-- -->，则演变序列的最短长度为5，一个可行的演变序列为&quot;hit&quot;→&quot;hot&quot;→&quot;dot&quot;→&quot;dog&quot;→&quot;cog&quot;。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-3">参考代码<a class="hash-link" href="#参考代码-3" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法一-2">解法一<a class="hash-link" href="#解法一-2" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; notVisited = new HashSet&lt;&gt;(wordList);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int length = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue1.add(beginWord);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue1.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String word = queue1.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (word.equals(endWord)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; neighbors = getNeighbors(word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String neighbor : neighbors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (notVisited.contains(neighbor)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue2.add(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                notVisited.remove(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (queue1.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            length++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue1 = queue2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue2 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private List&lt;String&gt; getNeighbors(String word) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; neighbors = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char[] chars = word.toCharArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; chars.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char old = chars[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ++ch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (old != ch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                chars[i] = ch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                neighbors.add(new String(chars));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        chars[i] = old;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return neighbors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法二-2">解法二<a class="hash-link" href="#解法二-2" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; notVisited = new HashSet&lt;&gt;(wordList);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!notVisited.contains(endWord)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; set1 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; set2 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int length = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set1.add(beginWord);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set2.add(endWord);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notVisited.remove(endWord);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (set2.size() &lt; set1.size()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Set&lt;String&gt; temp = set1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            set1 = set2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            set2 = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;String&gt; set3 = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String word : set1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;String&gt; neighbors = getNeighbors(word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (String neighbor : neighbors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (set2.contains(neighbor)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (notVisited.contains(neighbor)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    set3.add(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    notVisited.remove(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        length++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set1 = set3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private List&lt;String&gt; getNeighbors(String word) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; neighbors = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char[] chars = word.toCharArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; chars.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char old = chars[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ++ch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (old != ch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                chars[i] = ch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                neighbors.add(new String(chars));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        chars[i] = old;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return neighbors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题109开密码锁">面试题109：开密码锁<a class="hash-link" href="#面试题109开密码锁" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-4">题目<a class="hash-link" href="#题目-4" title="Direct link to heading">​</a></h3><p>一个密码锁由四个环形转轮组成，每个转轮由0到9十个数字组成。我们每次可以上下拨动一个转轮，比如可以将  一个转轮从0拨到9，也可以从9拨到0。密码锁由若干个死锁状态，一旦四个转轮被拨到某个死锁状态，这个锁就不可能打开了。密码锁的状态可以用一个长度为4的字符串表示，字符串中每个字符对应一个转轮上的数字。输入密码锁的密码和它的所有死锁状态，请问至少需要拨动转轮多少次才能从起始状态&quot;0000&quot;开始打开这个密码锁？</p><p>例如，如果某个密码锁的密码是&quot;0202&quot;，它的死锁状态列表是<!-- -->[&quot;0102&quot;, &quot;0201&quot;]<!-- -->，那么至少需要拨动转轮6次才能打开这个密码锁，一个可行的开锁状态序列是&quot;0000&quot;→&quot;1000&quot;→&quot;1100&quot;→&quot;1200&quot;→&quot;1201&quot;→&quot;1202&quot;→&quot;0202&quot;。虽然序列&quot;0000&quot;→&quot;0001&quot;→&quot;0002&quot;→&quot;0102&quot;→&quot;0202&quot;更短，只需要拨动4次转轮，但它包含死锁状态&quot;0102&quot;，因此这是一个无效的开锁序列。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-4">参考代码<a class="hash-link" href="#参考代码-4" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int openLock(String[] deadends, String target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; dead = new HashSet&lt;&gt;(Arrays.asList(deadends));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String init = &quot;0000&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dead.contains(init) || dead.contains(target)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int steps = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue1.offer(init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited.add(init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue1.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String cur = queue1.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cur.equals(target)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return steps;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; nexts = getNeighbors(cur);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String next : nexts) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!dead.contains(next) &amp;&amp; !visited.contains(next)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                visited.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue2.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (queue1.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            steps++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue1 = queue2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue2 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题110所有路径">面试题110：所有路径<a class="hash-link" href="#面试题110所有路径" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-5">题目<a class="hash-link" href="#题目-5" title="Direct link to heading">​</a></h3><p>一个有向无环图由n个结点（标号从0到n-1，n≥2）组成，请找出所有从结点0到结点n-1的所有路径。图用一个数组graph表示，数组的graph<!-- -->[i]<!-- -->包含所有从结点i能直接到达的结点。例如，输入数组graph为[<!-- -->[1,2]<!-- -->, <!-- -->[3]<!-- -->, <!-- -->[3]<!-- -->, []]，则输出两条从结点0到结点3的路径，分别为0→1→3和0→2→3，如图15.12所示。</p><p><img alt="图15.12" src="data:image/png;base64,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" width="159" height="149"></p><p>图15.12：一个有4个结点的有向无环图。从结点0到结点3有两条不同的路径，分别为0→1→3和0→2→3。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-5">参考代码<a class="hash-link" href="#参考代码-5" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dfs(0, graph, path, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void dfs(int source, int[][] graph, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    path.add(source);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (source == graph.length - 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result.add(new LinkedList&lt;Integer&gt;(path));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int next : graph[source]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dfs(next, graph, path, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    path.remove(path.size() - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}    </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题111计算除法">面试题111：计算除法<a class="hash-link" href="#面试题111计算除法" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-6">题目<a class="hash-link" href="#题目-6" title="Direct link to heading">​</a></h3><p>输入两个数组equations和values，其中数组equations的每一个元素包含两个表示变量名的字符串，数组values的每个元素是一个浮点数值。如果equations<!-- -->[i]<!-- -->的两个变量名分别是Ai和Bi，那么Ai/Bi=values<!-- -->[i]<!-- -->。再给你一个数组queries，它的每个元素也包含两个变量名。假设任意values<!-- -->[i]<!-- -->大于0。对于queries<!-- -->[j]<!-- -->的两个变量名为Cj和Dj，请计算Cj/Dj的结果。如果不能计算，那么返回-1。</p><p>例如，输入数组equations为[<!-- -->[&quot;a&quot;, &quot;b&quot;]<!-- -->, <!-- -->[&quot;b&quot;, &quot;c&quot;]<!-- -->]，数组values为<!-- -->[2.0, 3.0]<!-- -->，如果queries为[<!-- -->[&quot;a&quot;, &quot;c&quot;]<!-- -->, <!-- -->[&quot;b&quot;, &quot;a&quot;]<!-- -->, <!-- -->[&quot;a&quot;, &quot;e&quot;]<!-- -->, <!-- -->[&quot;a&quot;, &quot;a&quot;]<!-- -->, <!-- -->[&quot;x&quot;, &quot;x&quot;]<!-- -->]，那么对应的计算结果为<!-- -->[6.0, 0.5, -1.0, 1.0, -1.0]<!-- -->。由equations我们知道a/b=2.0、b/c=3.0，所以a/c=6.0、b/a=0.5、a/a=1.0。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-6">参考代码<a class="hash-link" href="#参考代码-6" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double[] results = new double[queries.size()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; queries.size(); ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String from = queries.get(i).get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String to = queries.get(i).get(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!graph.containsKey(from) || !graph.containsKey(to)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            results[i] = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            results[i] = dfs(graph, from, to, visited);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return results;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; equations.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String var1 = equations.get(i).get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String var2 = equations.get(i).get(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.putIfAbsent(var1, new HashMap&lt;String, Double&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.get(var1).put(var2, values[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.putIfAbsent(var2, new HashMap&lt;String, Double&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.get(var2).put(var1, 1.0/ values[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return graph;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private double dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, String from, String to, Set&lt;String&gt; visited) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (from.equals(to)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1.0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited.add(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Map.Entry&lt;String, Double&gt; entry : graph.get(from).entrySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String next = entry.getKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!visited.contains(next)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            double nextValue = dfs(graph, next, to, visited);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nextValue &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return entry.getValue() * nextValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited.remove(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1.0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题112最长递增路径">面试题112：最长递增路径<a class="hash-link" href="#面试题112最长递增路径" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-7">题目<a class="hash-link" href="#题目-7" title="Direct link to heading">​</a></h3><p>输入一个有整数组成的矩阵，请找出最长递增路径的长度。矩阵中的路径可以沿着上、下、左、右四个方向前行。例如，图15.10中矩阵的最长递增路径的长度为4，其中一条最长的递增路径为3→4→5→8，如阴影部分所示。 </p><p><img alt="图15.15" src="data:image/png;base64,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" width="107" height="115"></p><p>图15.15：矩阵中的路径可以沿着上、下、左、右四个方向前行，其中一条最长的递增路径为3→4→5→8（阴影部分），它的长度为4。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-7">参考代码<a class="hash-link" href="#参考代码-7" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int longestIncreasingPath(int[][] matrix) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (matrix.length == 0 || matrix[0].length == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] lengths = new int[matrix.length][matrix[0].length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int longest = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; matrix.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; matrix[0].length; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int length = dfs(matrix, lengths, i, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            longest = Math.max(longest, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return longest;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int dfs(int[][] matrix, int[][] lengths, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (lengths[i][j] != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return lengths[i][j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rows = matrix.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cols = matrix[0].length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[][] dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int length = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] dir : dirs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int r = i + dir[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = j + dir[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (r &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; cols </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;&amp; matrix[r][c] &gt; matrix[i][j]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int path = dfs(matrix, lengths, r, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            length = Math.max(path + 1, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lengths[i][j] = length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题113课程顺序">面试题113：课程顺序<a class="hash-link" href="#面试题113课程顺序" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-8">题目<a class="hash-link" href="#题目-8" title="Direct link to heading">​</a></h3><p>n门课程的编号从0到n-1。输入一个数组prerequisites，它的每个元素prerequisites<!-- -->[i]<!-- -->表示两门课程的先修顺序。如果prerequisites<!-- -->[i]<!-- -->=<!-- -->[ai, bi]<!-- -->，那么我们必须先修完可以bi才能修ai。请根据总课程数n和表示先修顺序的prerequisites得出一个可行的修课序列。如果有多个可行的修课序列，则输出任意序列。如果没有可行的修课序列，则输出空序列。例如，总共有4门课程，先修顺序prerequisites为[<!-- -->[1, 0]<!-- -->, <!-- -->[2, 0]<!-- -->, <!-- -->[3, 1]<!-- -->, <!-- -->[3, 2]<!-- -->]，一个可行的修课序列是0→2→1→3。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-8">参考代码<a class="hash-link" href="#参考代码-8" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int[] findOrder(int numCourses, int[][] prerequisites) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; numCourses; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.put(i, new LinkedList&lt;Integer&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] inDegrees = new int[numCourses];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] prereq : prerequisites) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.get(prereq[1]).add(prereq[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inDegrees[prereq[0]]++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; numCourses; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inDegrees[i] == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Integer&gt; order = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int course = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        order.add(course);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int next : graph.get(course)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inDegrees[next]--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (inDegrees[next] == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return order.size() == numCourses</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ? order.stream().mapToInt(i-&gt;i).toArray()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : new int[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题114外星文字典">面试题114：外星文字典<a class="hash-link" href="#面试题114外星文字典" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_mojV" id="题目-9">题目<a class="hash-link" href="#题目-9" title="Direct link to heading">​</a></h2><p>一种外星文语言的字母都是英文字母，但字母的顺序未知。给你该语言排序的单词列表，请推测可能的字母顺序。如果有多个可能的顺序，返回任意一个。如果没有满足条件的字母顺序，返回空字符串。例如，如果输入排序的单词列表为<!-- -->[&quot;ac&quot;, &quot;ab&quot;, &quot;bc&quot;, &quot;zc&quot;, &quot;zb&quot;]<!-- -->，那么一个可能的字母顺序是&quot;acbz&quot;。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-9">参考代码<a class="hash-link" href="#参考代码-9" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public String alienOrder(String[] words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (String word : words) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch : word.toCharArray()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.putIfAbsent(ch, new HashSet&lt;Character&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inDegrees.putIfAbsent(ch, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; words.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String w1 = words[i - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String w2 = words[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (w1.startsWith(w2) &amp;&amp; !w1.equals(w2)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; w1.length() &amp;&amp; j &lt; w2.length(); j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char ch1 = w1.charAt(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char ch2 = w2.charAt(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ch1 != ch2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!graph.get(ch1).contains(ch2)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    graph.get(ch1).add(ch2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inDegrees.put(ch2, inDegrees.get(ch2) + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (char ch : inDegrees.keySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inDegrees.get(ch) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue.add(ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder sb = new StringBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char ch = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sb.append(ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char next : graph.get(ch)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inDegrees.put(next, inDegrees.get(next) - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (inDegrees.get(next) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sb.length() == graph.size() ? sb.toString() : &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题115重建序列">面试题115：重建序列<a class="hash-link" href="#面试题115重建序列" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-10">题目<a class="hash-link" href="#题目-10" title="Direct link to heading">​</a></h3><p>长度为n的数组org是数字1到n的一个排列，seqs是若干个序列，请判断org是否为可由seqs重建的唯一序列。重建是指在seqs 中构建最短的公共超序列，即seqs 中的任意序列都是该最短序列的子序列。</p><p>例如，如果数组org为<!-- -->[4, 1, 5, 2, 6, 3]<!-- -->，而seqs为[<!-- -->[5, 2, 6, 3]<!-- -->, <!-- -->[4, 1, 5, 2]<!-- -->]，因为用[<!-- -->[5, 2, 6, 3]<!-- -->, <!-- -->[4, 1, 5, 2]<!-- -->]可以重建出唯一的序列<!-- -->[4, 1, 5, 2, 6, 3]<!-- -->，因此返回true。如果数组org为<!-- -->[1, 2, 3]<!-- -->，而seqs为[<!-- -->[1, 2]<!-- -->, <!-- -->[1, 3]<!-- -->]，因为用[<!-- -->[1, 2]<!-- -->, <!-- -->[1, 3]<!-- -->]可以重建出两个序列，<!-- -->[1, 2, 3]<!-- -->或者<!-- -->[1, 3, 2]<!-- -->，因此返回false。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-10">参考代码<a class="hash-link" href="#参考代码-10" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean sequenceReconstruction(int[] org, List&lt;List&lt;Integer&gt;&gt; seqs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (List&lt;Integer&gt; seq : seqs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int num : seq) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (num &lt; 1 || num &gt; org.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.putIfAbsent(num, new HashSet&lt;&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inDegrees.putIfAbsent(num, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; seq.size() - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int num1 = seq.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int num2 = seq.get(i + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!graph.get(num1).contains(num2)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                graph.get(num1).add(num2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inDegrees.put(num2, inDegrees.get(num2) + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : inDegrees.keySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inDegrees.get(num) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Integer&gt; built = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (queue.size() == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int num = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        built.add(num);            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int next : graph.get(num)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inDegrees.put(next, inDegrees.get(next) - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (inDegrees.get(next) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] result = new int[built.size()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = built.stream().mapToInt(i-&gt;i).toArray();        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Arrays.equals(result, org);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题116朋友圈">面试题116：朋友圈<a class="hash-link" href="#面试题116朋友圈" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-11">题目<a class="hash-link" href="#题目-11" title="Direct link to heading">​</a></h3><p>假设一个班上有n个同学。同学之间有些是朋友，有些不是。朋友关系是可以传递的。比如A是B的直接朋友，B是C的直接朋友，那么A是C的间接朋友。我们定义朋友圈就是一组直接或间接朋友的同学。输入一个n×n的矩阵M表示班上的朋友关系，如果M<!-- -->[i][j]<!-- -->=1,那么同学i和同学j是直接朋友。请计算该班朋友圈的数目？
例如输入数组[<!-- -->[1, 1, 0]<!-- -->, <!-- -->[1, 1, 0]<!-- -->, <!-- -->[0, 0, 1]<!-- -->]，则表明同学0和同学1是朋友，他们组成一个朋友圈。同学2一个人组成一个朋友圈。因此朋友圈的数目是2。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-11">参考代码<a class="hash-link" href="#参考代码-11" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法一-3">解法一<a class="hash-link" href="#解法一-3" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int findCircleNum(int[][] M) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean[] visited = new boolean[M.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int result = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; M.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!visited[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            findCircle(M, visited, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void findCircle(int[][] M, boolean[]visited, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited[i] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int t = queue.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int friend = 0; friend &lt; M.length; friend++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (M[t][friend] == 1 &amp;&amp; !visited[friend]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.add(friend);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                visited[friend] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法二-3">解法二<a class="hash-link" href="#解法二-3" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int findCircleNum(int[][] M) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] fathers = new int[M.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; fathers.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int count = M.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; M.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = i + 1; j &lt; M.length; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (M[i][j] == 1 &amp;&amp; union(fathers, i, j)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int findFather(int[] fathers, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fathers[i] != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = findFather(fathers, fathers[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fathers[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean union(int[] fathers, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfI = findFather(fathers, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfJ = findFather(fathers, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fatherOfI != fatherOfJ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[fatherOfI] = fatherOfJ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题117相似的字符串">面试题117：相似的字符串<a class="hash-link" href="#面试题117相似的字符串" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-12">题目<a class="hash-link" href="#题目-12" title="Direct link to heading">​</a></h3><p>如果交换字符串X中的两个字符能得到字符串Y，那么两个字符串X和Y相似。例如字符串&quot;tars&quot;和&quot;rats&quot;相似（交换下标0和2的两个字符）、字符串&quot;rats&quot;和&quot;arts&quot;相似（交换下标0和1的字符），但字符串&quot;star&quot;和&quot;tars&quot;不相似。</p><p>输入一个字符串数组，根据字符串的相似性分组，请问能把输入数组分成几组？如果一个字符串至少和一组字符串中的一个相似，那么它就可以放到该组里去。假设输入数组中的所有字符串长度相同并且两两互为变位词。例如输入数组<!-- -->[&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]<!-- -->，可以分成2组，一组为{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}，另一组为{&quot;star&quot;}。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-12">参考代码<a class="hash-link" href="#参考代码-12" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int numSimilarGroups(String[] A) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] fathers = new int[A.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; fathers.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int groups = A.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; A.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = i + 1; j &lt; A.length; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (similar(A[i], A[j]) &amp;&amp; union(fathers, i, j)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                groups--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int findFather(int[] fathers, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fathers[i] != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = findFather(fathers, fathers[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fathers[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean union(int[] fathers, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfI = findFather(fathers, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfJ = findFather(fathers, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fatherOfI != fatherOfJ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[fatherOfI] = fatherOfJ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题118多余的边">面试题118：多余的边<a class="hash-link" href="#面试题118多余的边" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-13">题目<a class="hash-link" href="#题目-13" title="Direct link to heading">​</a></h3><p>树可以看成是无环的无向图。在一个含有n个结点（结点标号从1到n）的树中添加一条边，就变成一个有环的图。给你一个往树里添加了一条边的图，请找出这条多余的边（用该边连接的两个结点表示）。输入的图由一个二维数组edges表示，数组的每个元素是由一条边连接的两个结点<!-- -->[u, v]<!-- -->（u&lt;v）。如果有多个答案，请输出在数组edges中最后出现的边。</p><p>例如，如果输入edges为[<!-- -->[1, 2]<!-- -->, <!-- -->[1, 3]<!-- -->, <!-- -->[2, 4]<!-- -->, <!-- -->[3, 4]<!-- -->, <!-- -->[2, 5]<!-- -->]，则它对应的无向图如图15.22所示。输出为边<!-- -->[3, 4]<!-- -->。</p><p><img alt="图15.22" src="data:image/png;base64,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" width="106" height="223"></p><p>图15.22：由边列表[<!-- -->[1, 2]<!-- -->, <!-- -->[1, 3]<!-- -->, <!-- -->[2, 4]<!-- -->, <!-- -->[3, 4]<!-- -->, <!-- -->[2, 5]<!-- -->]构成的图。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-13">参考代码<a class="hash-link" href="#参考代码-13" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int[] findRedundantConnection(int[][] edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int maxVertex = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] edge : edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxVertex = Math.max(maxVertex, edge[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxVertex = Math.max(maxVertex, edge[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] fathers = new int[maxVertex + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt;= maxVertex; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int[] edge : edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!union(fathers, edge[0], edge[1])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new int[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int findFather(int[] fathers, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fathers[i] != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[i] = findFather(fathers, fathers[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fathers[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean union(int[] fathers, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfI = findFather(fathers, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfJ = findFather(fathers, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fatherOfI != fatherOfJ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers[fatherOfI] = fatherOfJ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="面试题119最长连续序列">面试题119：最长连续序列<a class="hash-link" href="#面试题119最长连续序列" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="题目-14">题目<a class="hash-link" href="#题目-14" title="Direct link to heading">​</a></h3><p>输入一个无序的整数数组，请计算最长的连续数值序列的长度。例如，输入数组<!-- -->[10, 5, 9, 2, 4, 3]<!-- -->，则最长的连续数值序列是<!-- -->[2, 3, 4, 5]<!-- -->，因此输出4。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="参考代码-14">参考代码<a class="hash-link" href="#参考代码-14" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法一-4">解法一<a class="hash-link" href="#解法一-4" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int longestConsecutive(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int longest = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!set.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;Integer&gt; iter = set.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        longest = Math.max(longest, bfs(set, iter.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return longest;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int bfs(Set&lt;Integer&gt; set, int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.offer(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set.remove(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int length = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!queue.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i = queue.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] neighbors = new int[] {i - 1, i + 1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int neighbor : neighbors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (set.contains(neighbor)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.offer(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                set.remove(neighbor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                length++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="解法二-4">解法二<a class="hash-link" href="#解法二-4" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public int longestConsecutive(int[] nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, Integer&gt; fathers = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, Integer&gt; counts = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;Integer&gt; all = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers.put(num, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        counts.put(num, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        all.add(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (all.contains(num + 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            union(fathers, counts, num, num + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (all.contains(num - 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            union(fathers, counts, num, num - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int longest = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int length : counts.values()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        longest = Math.max(longest, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return longest;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int findFather(Map&lt;Integer, Integer&gt; fathers, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fathers.get(i) != i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers.put(i, findFather(fathers, fathers.get(i)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fathers.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void union(Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; counts, int i, int j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfI = findFather(fathers, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fatherOfJ = findFather(fathers, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fatherOfI != fatherOfJ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fathers.put(fatherOfI, fatherOfJ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int countOfI = counts.get(fatherOfI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int countOfJ = counts.get(fatherOfJ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        counts.put(fatherOfJ, countOfI + countOfJ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter14"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">第十四章：动态规划</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/leetcode/BST/leetcode96"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">leetcode96</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#面试题105最大的岛屿" class="table-of-contents__link toc-highlight">面试题105：最大的岛屿</a><ul><li><a href="#题目" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题106二分图" class="table-of-contents__link toc-highlight">面试题106：二分图</a><ul><li><a href="#题目-1" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-1" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题107矩阵中的距离" class="table-of-contents__link toc-highlight">面试题107：矩阵中的距离</a><ul><li><a href="#题目-2" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-2" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题108单词演变" class="table-of-contents__link toc-highlight">面试题108：单词演变</a><ul><li><a href="#题目-3" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-3" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题109开密码锁" class="table-of-contents__link toc-highlight">面试题109：开密码锁</a><ul><li><a href="#题目-4" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-4" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题110所有路径" class="table-of-contents__link toc-highlight">面试题110：所有路径</a><ul><li><a href="#题目-5" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-5" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题111计算除法" class="table-of-contents__link toc-highlight">面试题111：计算除法</a><ul><li><a href="#题目-6" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-6" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题112最长递增路径" class="table-of-contents__link toc-highlight">面试题112：最长递增路径</a><ul><li><a href="#题目-7" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-7" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题113课程顺序" class="table-of-contents__link toc-highlight">面试题113：课程顺序</a><ul><li><a href="#题目-8" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-8" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题114外星文字典" class="table-of-contents__link toc-highlight">面试题114：外星文字典</a></li><li><a href="#题目-9" class="table-of-contents__link toc-highlight">题目</a><ul><li><a href="#参考代码-9" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题115重建序列" class="table-of-contents__link toc-highlight">面试题115：重建序列</a><ul><li><a href="#题目-10" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-10" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题116朋友圈" class="table-of-contents__link toc-highlight">面试题116：朋友圈</a><ul><li><a href="#题目-11" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-11" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题117相似的字符串" class="table-of-contents__link toc-highlight">面试题117：相似的字符串</a><ul><li><a href="#题目-12" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-12" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题118多余的边" class="table-of-contents__link toc-highlight">面试题118：多余的边</a><ul><li><a href="#题目-13" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-13" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li><li><a href="#面试题119最长连续序列" class="table-of-contents__link toc-highlight">面试题119：最长连续序列</a><ul><li><a href="#题目-14" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#参考代码-14" class="table-of-contents__link toc-highlight">参考代码</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.06e72fca.js"></script>
<script src="/richardgong1987-learn/assets/js/main.c82129bb.js"></script>
</body>
</html>