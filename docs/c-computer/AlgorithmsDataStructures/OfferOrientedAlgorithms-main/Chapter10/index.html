<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">第十章：前缀树 | 学习大使</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="第十章：前缀树 | 学习大使"><meta data-react-helmet="true" name="description" content="面试题62：实现前缀树"><meta data-react-helmet="true" property="og:description" content="面试题62：实现前缀树"><link data-react-helmet="true" rel="shortcut icon" href="/richardgong1987-learn/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://richardgong1987-learn.github.io/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10" hreflang="x-default"><link rel="stylesheet" href="/richardgong1987-learn/assets/css/styles.87861f0e.css">
<link rel="preload" href="/richardgong1987-learn/assets/js/runtime~main.596c2f28.js" as="script">
<link rel="preload" href="/richardgong1987-learn/assets/js/main.279dec3d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/richardgong1987-learn/"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/richardgong1987-learn/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">学习大使</b></a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/a-java/intro">Java架构师</a><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/b-rust/intro">Rust架构师</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link navbar__link--active" href="/richardgong1987-learn/docs/c-computer/intro">计算机科学</a><a href="https://github.com/richardgong1987-learn/richardgong1987-learn.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java架构师</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/richardgong1987-learn/docs/intro">学习大使</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">rust架构师</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">计算机机科学</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/intro">计算机机科学内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">AlgorithmsDataStructures</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/intro">算法与数据结构内容目录</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">BinaryTree</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">OfferOrientedAlgorithms-main</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter01">第一章：整数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter02">第二章：数组</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter03">第三章：字符串</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter04">第四章：链表</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter05">第五章：哈希表</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter06">第六章：栈</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter07">第七章：队列</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter08">第八章：树</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter09">第九章：堆</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10">第十章：前缀树</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter11">第十一章：二分查找</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter12">第十二章：排序</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter13">第十三章：回溯法</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter14">第十四章：动态规划</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter15">第十五章：图</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/README">剑指Offer</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">algorithm_cheat_sheet</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">labuladong算法小抄代码</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>第十章：前缀树</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题62：实现前缀树"></a>面试题62：实现前缀树<a class="hash-link" href="#面试题62：实现前缀树" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目"></a>题目<a class="hash-link" href="#题目" title="Direct link to heading">#</a></h3><p>请设计实现一个前缀树Trie，它有如下操作：</p><ul><li>函数insert，往前缀树里添加一个字符串。</li><li>函数search，查找字符串。如果前缀树里包含该字符串，返回true；否则返回false。</li><li>函数startWith，查找字符串前缀。如果前缀树里包含以该前缀开头的字符串，返回true；否则返回false。</li></ul><p>例如，调用函数insert往前缀树里添加单词&quot;goodbye&quot;之后，输入&quot;good&quot;调用函数search返回false，但输入&quot;good&quot;调用函数startWide返回true。再次调用函数insert添加单词&quot;good&quot;之后，此时再输入&quot;good&quot;调用函数search则返回true。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码"></a>参考代码<a class="hash-link" href="#参考代码" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Trie {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private TrieNode root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class TrieNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode children[];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean isWord;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TrieNode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            children = new TrieNode[26];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Trie() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insert(String word) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch : word.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.children[ch - &#x27;a&#x27;] = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.isWord = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean search(String word) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch : word.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return node.isWord;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean startsWith(String prefix) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch : prefix.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题63：替换单词"></a>面试题63：替换单词<a class="hash-link" href="#面试题63：替换单词" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目-1"></a>题目<a class="hash-link" href="#题目-1" title="Direct link to heading">#</a></h3><p>英语里有一个概念叫词根。我们在词根后面加上若干字符就能拼出更长的单词。例如&quot;an&quot;是一个词根，在它后面加上&quot;other&quot;就能得到另一个单词&quot;another&quot;。现在给你一个由词根组成的字典和一个英语句子，如果句子中的单词在字典里有它的词根，则用它的词根替换该单词；如果单词没有词根，则保留该单词。请输出替换后的句子。例如，如果词根字典包含字符串[&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]，英语句子为&quot;the cattle was rattled by the battery&quot;，则替换之后的句子是&quot;the cat was rat by the bat&quot;。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码-1"></a>参考代码<a class="hash-link" href="#参考代码-1" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">static class TrieNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode[] children;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isWord;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        children = new TrieNode[26];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public String replaceWords(List&lt;String&gt; dict, String sentence) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = buildTrie(dict);            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder builder = new StringBuilder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] words = sentence.split(&quot; &quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; words.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String prefix = findPrefix(root, words[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!prefix.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            words[i] = prefix;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return String.join(&quot; &quot;, words);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private TrieNode buildTrie(List&lt;String&gt; dict) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (String word : dict) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (char ch : word.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.children[ch - &#x27;a&#x27;] = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.isWord = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private String findPrefix(TrieNode root, String word) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder builder = new StringBuilder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (char ch : word.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node.isWord || node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        builder.append(ch);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node.isWord ? builder.toString() : &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题64：神奇的字典"></a>面试题64：神奇的字典<a class="hash-link" href="#面试题64：神奇的字典" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目-2"></a>题目<a class="hash-link" href="#题目-2" title="Direct link to heading">#</a></h3><p>请实现有如下两个操作的神奇字典：</p><ul><li>函数buildDict，输入单词数组用来创建一个字典。</li><li>函数search，输入一个单词，判断能否修改该单词中的一个字符使得修改之后的单词是字典中的一个单词。</li></ul><p>例如输入[&quot;happy&quot;, &quot;new&quot;, &quot;year&quot;]创建一个神奇字典。如果输入单词&quot;now&quot;进行search操作，由于将其中的&#x27;o&#x27;修改成&#x27;e&#x27;就得到字典中的&quot;new&quot;，因此返回true。如果输入单词&quot;new&quot;，将其中任意字符修改成另一不同的字符都不能得到字典里的单词，因此返回false。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码-2"></a>参考代码<a class="hash-link" href="#参考代码-2" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class MagicDictionary {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class TrieNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TrieNode[] children;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isWord;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TrieNode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            children = new TrieNode[26];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MagicDictionary() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void buildDict(String[] dict) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String word : dict) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (char ch : word.toCharArray()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node.children[ch - &#x27;a&#x27;] = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node.isWord = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean search(String word) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dfs(root, word, 0, 0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean dfs(TrieNode root, String word, int i, int edit) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (root == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (root.isWord &amp;&amp; i == word.length() &amp;&amp; edit == 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i &lt; word.length() &amp;&amp; edit &lt;= 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean found = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; 26 &amp;&amp; !found; j++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                int next = j == word.charAt(i) - &#x27;a&#x27; ? edit : edit + 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                found = dfs(root.children[j], word, i + 1, next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return found;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题65：最短的单词编码"></a>面试题65：最短的单词编码<a class="hash-link" href="#面试题65：最短的单词编码" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目-3"></a>题目<a class="hash-link" href="#题目-3" title="Direct link to heading">#</a></h3><p>给定一个含有n个单词的数组，我们可以把它们编码成一个字符串和n个下标。假如给定单词数组[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，我们可以把它们编码成一个字符串&quot;time#bell#&quot;，然后这些单词就可以通过下标[0, 2, 5]得到。对于每一个下标，我们都可以从编码之后得到的字符串中相应的位置开始扫描直到遇到&quot;#&quot;字符前所经过的子字符串为单词数组中的一个单词。例如从&quot;time#bell#&quot;下标2的位置开始扫描直到遇到&quot;#&quot;前经过子字符串&quot;me&quot;是给定单词数组的第二个单词。</p><p>给我们一个单词数组，请问按照上述规则把这些单词编码之后得到的最短字符串的长度是多少？如果输入是字符串数组[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，编码之后最短的字符串是&quot;time#bell#&quot;，长度是10。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码-3"></a>参考代码<a class="hash-link" href="#参考代码-3" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">static class TrieNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode[] children;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        children = new TrieNode[26];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public int minimumLengthEncoding(String[] words) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = buildTrie(words);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int total[] = {0};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dfs(root, 1, total);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return total[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private TrieNode buildTrie(String[] words) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (String word : words) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = word.length() - 1; i &gt;= 0; i--) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            char ch = word.charAt(i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.children[ch - &#x27;a&#x27;] = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void dfs(TrieNode root, int length, int[] total) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isLeaf = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (TrieNode child : root.children) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (child != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            isLeaf = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            dfs(child, length + 1, total);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isLeaf) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        total[0] += length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题66：单词之和"></a>面试题66：单词之和<a class="hash-link" href="#面试题66：单词之和" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目-4"></a>题目<a class="hash-link" href="#题目-4" title="Direct link to heading">#</a></h3><p>请设计实现一个类型MapSum，它有如下两个操作：</p><ul><li>函数insert，输入一个字符串和一个整数，往数据集合中添加一个字符串以及它对应的值。如果数据集合中已经包含该字符串，则将该字符串对应的值替换成新值。</li><li>函数sum，输入一个字符串，返回数据集合里所有以该字符串为前缀的字符串对应值之和。</li></ul><p>例如，第一次调用函数insert添加字符串&quot;happy&quot;和它的值3，此时如果输入&quot;hap&quot;调用sum则返回3。第二次再用函数insert添加字符串&quot;happen&quot;和它的值2，此时如果输入&quot;hap&quot;调用sum则返回5。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码-4"></a>参考代码<a class="hash-link" href="#参考代码-4" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class MapSum {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class TreeNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TreeNode[] children;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public TreeNode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            children = new TreeNode[26];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private TreeNode root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MapSum() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = new TreeNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insert(String key, int val) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TreeNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; key.length(); ++i) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            char ch = key.charAt(i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.children[ch - &#x27;a&#x27;] = new TreeNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.value = val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int sum(String prefix) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TreeNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; prefix.length(); ++i) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            char ch = prefix.charAt(i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[ch - &#x27;a&#x27;] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[ch - &#x27;a&#x27;];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getSum(node);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int getSum(TreeNode node) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = node.value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (TreeNode child : node.children) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result += getSum(child);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="面试题67：最大的异或"></a>面试题67：最大的异或<a class="hash-link" href="#面试题67：最大的异或" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="题目-5"></a>题目<a class="hash-link" href="#题目-5" title="Direct link to heading">#</a></h3><p>输入一个整数数组（每个数字都大于或者等于0），请计算其中任意两个数的异或的最大值。例如在数组[1, 3, 4, 7]中，3和4的异或结果最大，异或结果为7。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参考代码-5"></a>参考代码<a class="hash-link" href="#参考代码-5" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">static class TrieNode {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode[] children;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrieNode () {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        children = new TrieNode[2];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public int findMaximumXOR(int[] nums) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = buildTrie(nums);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int max = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int xor = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 31; i &gt;= 0; i--) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bit = (num &gt;&gt; i) &amp; 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[1 - bit] != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                xor = (xor &lt;&lt; 1) + 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node = node.children[1 - bit];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                xor = xor &lt;&lt; 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node = node.children[bit];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        max = Math.max(max, xor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return max;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private TrieNode buildTrie(int[] nums) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TrieNode root = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int num : nums) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TrieNode node = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 31; i &gt;= 0; i--) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bit = (num &gt;&gt; i) &amp; 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.children[bit] == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.children[bit] = new TrieNode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.children[bit];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/richardgong1987-learn/richardgong1987-learn/edit/master/website/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter10.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter09"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 第九章：堆</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/richardgong1987-learn/docs/c-computer/AlgorithmsDataStructures/OfferOrientedAlgorithms-main/Chapter11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">第十一章：二分查找 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#面试题62：实现前缀树" class="table-of-contents__link">面试题62：实现前缀树</a><ul><li><a href="#题目" class="table-of-contents__link">题目</a></li><li><a href="#参考代码" class="table-of-contents__link">参考代码</a></li></ul></li><li><a href="#面试题63：替换单词" class="table-of-contents__link">面试题63：替换单词</a><ul><li><a href="#题目-1" class="table-of-contents__link">题目</a></li><li><a href="#参考代码-1" class="table-of-contents__link">参考代码</a></li></ul></li><li><a href="#面试题64：神奇的字典" class="table-of-contents__link">面试题64：神奇的字典</a><ul><li><a href="#题目-2" class="table-of-contents__link">题目</a></li><li><a href="#参考代码-2" class="table-of-contents__link">参考代码</a></li></ul></li><li><a href="#面试题65：最短的单词编码" class="table-of-contents__link">面试题65：最短的单词编码</a><ul><li><a href="#题目-3" class="table-of-contents__link">题目</a></li><li><a href="#参考代码-3" class="table-of-contents__link">参考代码</a></li></ul></li><li><a href="#面试题66：单词之和" class="table-of-contents__link">面试题66：单词之和</a><ul><li><a href="#题目-4" class="table-of-contents__link">题目</a></li><li><a href="#参考代码-4" class="table-of-contents__link">参考代码</a></li></ul></li><li><a href="#面试题67：最大的异或" class="table-of-contents__link">面试题67：最大的异或</a><ul><li><a href="#题目-5" class="table-of-contents__link">题目</a></li><li><a href="#参考代码-5" class="table-of-contents__link">参考代码</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/richardgong1987-learn/assets/js/runtime~main.596c2f28.js"></script>
<script src="/richardgong1987-learn/assets/js/main.279dec3d.js"></script>
</body>
</html>